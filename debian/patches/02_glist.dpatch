#! /bin/sh /usr/share/dpatch/dpatch-run
## 02_glist.dpatch by  <paul@nfg.nl>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad dbmail-2.1/acl.c /tmp/dpep.MIMNv7/dbmail-2.1/acl.c
--- dbmail-2.1/acl.c	2004-09-14 17:30:40.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/acl.c	2004-11-16 09:29:02.000000000 +0100
@@ -199,17 +199,16 @@
 	char *identifier;	/* one identifier */
 	char rightsstring[NR_ACL_FLAGS + 1];
 	int result;
-	struct list identifier_list;
-	struct element *identifier_elm;
+	list * identifier_list;
 	unsigned nr_identifiers = 0;
 
-	result = db_acl_get_identifier(mboxid, &identifier_list);
+	result = db_acl_get_identifier(mboxid, identifier_list);
 
 	if (result < 0) {
 		trace(TRACE_ERROR, "%s,%s: error when getting identifier "
 		      "list for mailbox [%llu].", __FILE__, __func__,
 		      mboxid);
-		list_freelist(&identifier_list.start);
+		list_freelist(identifier_list);
 		return NULL;
 	}
 
@@ -219,43 +218,40 @@
 	if (db_get_mailbox_owner(mboxid, &userid) < 0) {
 		trace(TRACE_ERROR, "%s,%s: error querying ownership of "
 		      "mailbox", __FILE__, __func__);
-		list_freelist(&identifier_list.start);
+		list_freelist(identifier_list);
 		return NULL;
 	}
 
 	if ((username = auth_get_userid(userid)) == NULL) {
 		trace(TRACE_ERROR, "%s,%s: error getting username for "
 		      "user [%llu]", __FILE__, __func__, userid);
-		list_freelist(&identifier_list.start);
+		list_freelist(identifier_list);
 		return NULL;
 	}
-	if (list_nodeadd(&identifier_list, username, 
-			 strlen(username) + 1) == NULL) { 
+	if (! (identifier_list = list_nodeadd(identifier_list, username, strlen(username) + 1))) { 
 		trace(TRACE_ERROR, "%s,%s: error adding username to list",
 		      __FILE__, __func__);
-		list_freelist(&identifier_list.start);
+		list_freelist(identifier_list);
 		my_free(username);
 		return NULL;
 	}
 	my_free(username);
 
-	identifier_elm = list_getstart(&identifier_list);
+	identifier_list = list_first(identifier_list);
 	trace(TRACE_DEBUG, "%s,%s: before looping identifiers!",
 	      __FILE__, __func__);
-	while (identifier_elm) {
+	while (identifier_list) {
 		nr_identifiers++;
-		acl_string_size += strlen((char *) identifier_elm->data)
+		acl_string_size += strlen((char *) identifier_list->data)
 		    + NR_ACL_FLAGS + 2;
-		identifier_elm = identifier_elm->nextnode;
+		identifier_list = list_next(identifier_list);
 	}
 
 	trace(TRACE_DEBUG, "%s,%s: acl_string size = %zd",
 	      __FILE__, __func__, acl_string_size);
 
-	if (!
-	    (acl_string =
-	     my_malloc((acl_string_size + 1) * sizeof(char)))) {
-		list_freelist(&identifier_list.start);
+	if (!  (acl_string = my_malloc((acl_string_size + 1) * sizeof(char)))) {
+		list_freelist(identifier_list);
 		trace(TRACE_FATAL, "%s,%s: error allocating memory",
 		      __FILE__, __func__);
 		return NULL;
@@ -263,15 +259,16 @@
 	// initialise list to length 0
 	acl_string[0] = '\0';
 	memset((void *) acl_string, '\0', acl_string_size + 1);
-	identifier_elm = list_getstart(&identifier_list);
-	while (identifier_elm) {
-		identifier = (char *) identifier_elm->data;
+	
+	identifier_list = list_first(identifier_list);
+	while (identifier_list) {
+		identifier = (char *) identifier_list->data;
 		if (acl_get_rightsstring_identifier(identifier, mboxid,
 						    rightsstring) < 0) {
 			trace(TRACE_ERROR, "%s,%s: error getting string "
 			      "rights for user with name [%s].",
 			      __FILE__, __func__, identifier);
-			list_freelist(&identifier_list.start);
+			list_freelist(identifier_list);
 			my_free(acl_string);
 			return NULL;
 		}
@@ -283,10 +280,10 @@
 					acl_string_size - acl_strlen,
 					"%s %s ", identifier, rightsstring);
 		}
-		identifier_elm = identifier_elm->nextnode;
+		identifier_list = list_next(identifier_list);
 
 	}
-	list_freelist(&identifier_list.start);
+	list_freelist(identifier_list);
 	return acl_string;
 }
 
diff -urNad dbmail-2.1/auth/authldap.c /tmp/dpep.MIMNv7/dbmail-2.1/auth/authldap.c
--- dbmail-2.1/auth/authldap.c	2004-09-10 10:02:56.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/auth/authldap.c	2004-11-16 09:29:02.000000000 +0100
@@ -245,10 +245,10 @@
  * retlist
  *  has the "rows" that matched
  *   {
- *     (struct list *)data
+ *     (list *)data
  *       has the fields you requested
  *       {
- *         (struct list *)data
+ *         (list *)data
  *           has the values for the field
  *           {
  *             (char *)data
@@ -262,7 +262,7 @@
 
 /* returns the number of matches found */
 int __auth_get_one_entry(const char *q, char **retfields,
-			 struct list *retlist)
+			 list *retlist)
 {
 	LDAPMessage *ldap_res;
 	LDAPMessage *ldap_msg;
@@ -273,7 +273,7 @@
 	char **ldap_attrs = NULL;
 	char ldap_query[AUTH_QUERY_SIZE];
 	int i = 0, j = 0, k = 0, m = 0;
-	struct list fieldlist, datalist;
+	list *fieldlist, *datalist;
 
 	if (!q) {
 		trace(TRACE_ERROR,
@@ -324,12 +324,12 @@
 	/* get the entries to populate retlist */
 	for (i = 0; i < j; i++) {
 		/* init this list for the field values */
-		list_init(&fieldlist);
+		list_init(fieldlist);
 
 		/* get the fields to populate fieldlist */
 		for (k = 0; retfields[k] != NULL; k++) {
 			/* init this list for the data values */
-			list_init(&datalist);
+			list_init(datalist);
 
 			/* get the values to populate datalist */
 			ldap_vals =
@@ -350,34 +350,29 @@
 			} else {
 				for (m = 0; ldap_vals[m] != NULL; m++) {
 					/* add the value to the list */
-					if (!list_nodeadd
-					    (&datalist, ldap_vals[m],
-					     strlen(ldap_vals[m]) + 1)) {
+					if (!( datalist = list_nodeadd (datalist, ldap_vals[m], strlen(ldap_vals[m]) + 1))) {
 						trace(TRACE_ERROR,
-						      "%s,%s: could not add ldap_vals to &datalist",__FILE__,__func__);
-						list_freelist(&datalist.
-							      start);
+						      "%s,%s: could not add ldap_vals to datalist",__FILE__,__func__);
+						list_freelist(datalist);
 						break;
 					}
 				}
 			}
 			/* add the value to the list */
-			if (!list_nodeadd
-			    (&fieldlist, &datalist, sizeof(struct list))) {
+			if (!(fieldlist = list_nodeadd(fieldlist, datalist, sizeof(list)))) {
 				trace(TRACE_ERROR,
-				      "%s,%s: could not add &datalist to &fieldlist",__FILE__,__func__);
-				list_freelist(&fieldlist.start);
+				      "%s,%s: could not add datalist to fieldlist",__FILE__,__func__);
+				list_freelist(fieldlist);
 				break;
 			}
 			/* free the values as we use them */
 			ldap_value_free(ldap_vals);
 		}
 		/* add the value to the list */
-		if (!list_nodeadd
-		    (retlist, &fieldlist, sizeof(struct list))) {
+		if (! (*(list **)retlist = list_nodeadd (*(list **)retlist, fieldlist, sizeof(list)))) {
 			trace(TRACE_ERROR,
-			      "%s,%s: could not add &fieldlist to retlist",__FILE__,__func__);
-			list_freelist(&retlist->start);
+			      "%s,%s: could not add fieldlist to retlist",__FILE__,__func__);
+			list_freelist(retlist);
 			goto endfree;
 		}
 
@@ -404,7 +399,7 @@
 
 /* returns the number of matches found */
 int __auth_get_every_match(const char *q, char **retfields,
-			   struct list *retlist)
+			   list *retlist)
 {
 	LDAPMessage *ldap_res;
 	LDAPMessage *ldap_msg;
@@ -415,7 +410,7 @@
 	char **ldap_attrs = NULL;
 	char ldap_query[AUTH_QUERY_SIZE];
 	int i = 0, j = 0, k = 0, m = 0;
-	struct list fieldlist, datalist;
+	list *fieldlist, *datalist;
 
 	if (!q) {
 		trace(TRACE_ERROR,
@@ -472,12 +467,12 @@
 	/* get the entries to populate retlist */
 	for (i = 0; i < j; i++) {
 		/* init this list for the field values */
-		list_init(&fieldlist);
+		list_init(fieldlist);
 
 		/* get the fields to populate fieldlist */
 		for (k = 0; retfields[k] != NULL; k++) {
 			/* init this list for the data values */
-			list_init(&datalist);
+			list_init(datalist);
 
 			/* get the values to populate datalist */
 			ldap_vals =
@@ -498,34 +493,29 @@
 			} else {
 				for (m = 0; ldap_vals[m] != NULL; m++) {
 					/* add the value to the list */
-					if (!list_nodeadd
-					    (&datalist, ldap_vals[m],
-					     strlen(ldap_vals[m]) + 1)) {
+					if (! (datalist = list_nodeadd(datalist, ldap_vals[m], strlen(ldap_vals[m]) + 1))) {
 						trace(TRACE_ERROR,
-						      "%s,%s: could not add ldap_vals to &datalist",__FILE__,__func__);
-						list_freelist(&datalist.
-							      start);
+						      "%s,%s: could not add ldap_vals to datalist",__FILE__,__func__);
+						list_freelist(datalist);
 						break;
 					}
 				}
 			}
 			/* add the value to the list */
-			if (!list_nodeadd
-			    (&fieldlist, &datalist, sizeof(struct list))) {
+			if (! (fieldlist = list_nodeadd(fieldlist, datalist, sizeof(list)))) {
 				trace(TRACE_ERROR,
-				      "%s,%s: could not add &datalist to &fieldlist",__FILE__,__func__);
-				list_freelist(&fieldlist.start);
+				      "%s,%s: could not add datalist to fieldlist",__FILE__,__func__);
+				list_freelist(fieldlist);
 				break;
 			}
 			/* free the values as we use them */
 			ldap_value_free(ldap_vals);
 		}
 		/* add the value to the list */
-		if (!list_nodeadd
-		    (retlist, &fieldlist, sizeof(struct list))) {
+		if (! (*(list **)retlist = list_nodeadd (*(list **)retlist, fieldlist, sizeof(list)))) {
 			trace(TRACE_ERROR,
-			      "%s,%s: could not add &fieldlist to retlist",__FILE__,__func__);
-			list_freelist(&retlist->start);
+			      "%s,%s: could not add fieldlist to retlist",__FILE__,__func__);
+			list_freelist(retlist);
 			goto endfree;
 		}
 
@@ -773,14 +763,13 @@
 
 /* Fills the users list with all existing users
  * return -2 on mem error, -1 on db-error, 0 on success */
-int auth_get_known_users(struct list *users)
+int auth_get_known_users(list *users)
 {
 	int64_t known;
 	/* u64_t curr; unused variable */
 	char query[AUTH_QUERY_SIZE];
 	char *fields[] = { _ldap_cfg.field_uid, NULL };
-	struct list templist;
-	struct element *tempelem1, *tempelem2, *tempelem3;
+	list *templist1, *templist2, *templist3;
 
 	if (!users) {
 		trace(TRACE_ERROR,
@@ -792,29 +781,25 @@
 
 	snprintf(query, AUTH_QUERY_SIZE, "(objectClass=%s)",
 		 _ldap_cfg.objectclass);
-	known = __auth_get_every_match(query, fields, &templist);
+	known = __auth_get_every_match(query, fields, templist1);
 	trace(TRACE_ERROR, "%s,%s: found %llu users",__FILE__,__func__,
 	      known);
 
 	/* do the first entry here */
-	tempelem1 = list_getstart(&templist);
+	templist1 = list_first(templist1);
 
 	/* we'll get the next entry at the _end_ of the loop! */
-	while (tempelem1 != NULL) {
-		tempelem2 = list_getstart((struct list *) tempelem1->data);
-		while (tempelem2 != NULL) {
-			tempelem3 =
-			    list_getstart((struct list *) tempelem2->data);
-			while (tempelem3 != NULL) {
-				list_nodeadd(users,
-					     (char *) tempelem3->data,
-					     strlen((char *) tempelem3->
-						    data) + 1);
-				tempelem3 = tempelem3->nextnode;
+	while (templist1) {
+		templist2 = list_first(templist1->data);
+		while (templist2) {
+			templist3 = list_first(templist2->data);
+			while (templist3) {
+				*(list **)users = list_nodeadd(*(list **)users, (char *) templist3->data, strlen((char *) templist3-> data) + 1);
+				templist3=list_next(templist3);
 			}
-			tempelem2 = tempelem2->nextnode;
+			templist2 = list_next(templist2);
 		}
-		tempelem1 = tempelem1->nextnode;
+		templist1 = list_next(templist1);
 	}
 
 	/* pass through any error from __auth_get_every_match() */
@@ -823,7 +808,7 @@
 
 
 /* recursive function, should be called with checks == -1 from main routine */
-int auth_check_user(const char *address, struct list *userids, int checks)
+int auth_check_user(const char *address, list *userids, int checks)
 {
 	int occurences = 0, r;
 	/*int i; unused variable */
@@ -832,8 +817,7 @@
 	char *fields[] = { _ldap_cfg.field_nid, NULL };
 	int c1, c2, c3;
 	int count1, count2, count3;
-	struct list templist;
-	struct element *tempelem1, *tempelem2, *tempelem3;
+	list *templist1, *templist2, *templist3;
 
 
 	trace(TRACE_DEBUG, "%s,%s: checking for user [%s]",__FILE__,__func__,
@@ -845,14 +829,14 @@
 		return -1;
 	}
 
-	list_init(&templist);
+	list_init(templist1);
 
 	snprintf(query, AUTH_QUERY_SIZE, "(|(%s=%s)(%s=%s%s))",
 		 _ldap_cfg.field_mail, address, _ldap_cfg.field_mailalt,
 		 _ldap_cfg.mailaltprefix, address);
 
 	/* we're just using a little counter variable, since we'll use it in the for loop later */
-	j = __auth_get_every_match(query, fields, &templist);
+	j = __auth_get_every_match(query, fields, templist1);
 
 	if (j < 1) {
 		if (checks > 0) {
@@ -860,73 +844,51 @@
 			 * but checks needs to be bigger then 0 because
 			 * else it could be the first query failure */
 
-			list_nodeadd(userids, address,
-				     strlen(address) + 1);
-			trace(TRACE_DEBUG,
-			      "%s,%s: adding [%s] to deliver_to address",__FILE__,__func__,
-			      address);
-			list_freelist(&templist.start);
+			*(list **)userids = list_nodeadd(*(list **)userids, address, strlen(address) + 1);
+			trace(TRACE_DEBUG, "%s,%s: adding [%s] to deliver_to address",__FILE__,__func__, address);
+			list_freelist(templist1);
 			return 1;
 		} else {
-			trace(TRACE_DEBUG,
-			      "%s,%s: user [%s] not in aliases table",__FILE__,__func__,
-			      address);
-			list_freelist(&templist.start);
+			trace(TRACE_DEBUG, "%s,%s: user [%s] not in aliases table",__FILE__,__func__, address);
+			list_freelist(templist1);
 			return 0;
 		}
 	}
 
 	/* do the first entry here */
-	tempelem1 = list_getstart(&templist);
-
-	count1 = templist.total_nodes;
-	for (c1 = 0; c1 < count1; c1++) {
-		tempelem2 = list_getstart((struct list *) tempelem1->data);
-		count2 = ((struct list *) tempelem1->data)->total_nodes;
-		for (c2 = 0; c2 < count2; c2++) {
-			tempelem3 =
-			    list_getstart((struct list *) tempelem2->data);
-			count3 =
-			    ((struct list *) tempelem2->data)->total_nodes;
-			for (c3 = 0; c3 < count3; c3++) {
-// here begins the meat
+	templist1 = list_first(templist1);
+	while(templist1) {
+		templist2 = templist1->data;
+		while(templist2) {
+			templist3 = templist2->data;
+			// here begins the meat
+			while(templist3) { 
 				/* do a recursive search for deliver_to */
 				trace(TRACE_DEBUG,
 				      "%s,%s: checking user [%s] to [%s]",__FILE__,__func__,
-				      address, (char *) tempelem3->data);
+				      address, (char *) templist3->data);
 
-				r = auth_check_user((char *) tempelem3->
-						    data, userids,
-						    (checks <
-						     0) ? 1 : checks + 1);
+				r = auth_check_user((char *) templist3->data, userids, (checks < 0) ? 1 : checks + 1);
 
 				if (r < 0) {
 					/* loop detected */
-
 					if (checks > 0)
 						return -1;	/* still in recursive call */
-
-					if (userids->start) {
-						list_freelist(&userids->
-							      start);
-						userids->total_nodes = 0;
-					}
-
+					if (userids)
+						list_freelist(userids);
 					return 0;	/* report to calling routine: no results */
 				}
-
 				occurences += r;
-// here ends the meat
-				tempelem3 = tempelem3->nextnode;
+				templist3 = list_next(templist3);
 			}
-			list_freelist(&((struct list *) tempelem2->data)->
-				      start);
-			tempelem2 = tempelem2->nextnode;
+			// here ends the meat
+			list_freelist(templist3);
+			templist2 = list_next(templist2);
 		}
-		list_freelist(&((struct list *) tempelem1->data)->start);
-		tempelem1 = tempelem1->nextnode;
+		list_freelist(templist2);
+		templist1 = list_next(templist1);
 	}
-	list_freelist(&templist.start);
+	list_freelist(templist1);
 
 	trace(TRACE_DEBUG,
 	      "%s,%s: executing query, checks [%d]",__FILE__,__func__, checks);
@@ -945,8 +907,8 @@
  * 
  * returns the number of occurences. 
  */
-int auth_check_user_ext(const char *address, struct list *userids,
-			struct list *fwds, int checks)
+int auth_check_user_ext(const char *address, list *userids,
+			list *fwds, int checks)
 {
 	/*int i; unused variable */
 	int j;
@@ -960,8 +922,7 @@
        _ldap_cfg.field_fwdtarget, NULL };
 	int c1, c2, c3;
 	int count1, count2, count3;
-	struct list templist;
-	struct element *tempelem1, *tempelem2, *tempelem3;
+	list *templist1, *templist2, *templist3;
 
 	trace(TRACE_DEBUG,
 	      "%s,%s: checking user [%s] in alias table",__FILE__,__func__,
@@ -970,7 +931,7 @@
 	/* This is my private line for sending a DN rather than a search */
 	if (checks < -1) {
 		snprintf(query, AUTH_QUERY_SIZE, "%s", address);
-		j = __auth_get_one_entry(query, fields, &templist);
+		j = __auth_get_one_entry(query, fields, templist1);
 	} else {
 		snprintf(query, AUTH_QUERY_SIZE, "(|(%s=%s)(%s=%s%s))",
 			 _ldap_cfg.field_mail, address,
@@ -978,7 +939,7 @@
 			 address);
 		/* we're just using a little counter variable,
 		 * since we'll use it in the for loop later */
-		j = __auth_get_every_match(query, fields, &templist);
+		j = __auth_get_every_match(query, fields, templist1);
 	}
 
 
@@ -997,23 +958,22 @@
 			id = strtoull(address, &endptr, 10);
 			if (*endptr == 0) {
 				/* numeric deliver-to --> this is a userid */
-				list_nodeadd(userids, &id, sizeof(id));
+				*(list **)userids = list_nodeadd(*(list **)userids, &id, sizeof(id));
 			} else {
-				list_nodeadd(fwds, address,
-					     strlen(address) + 1);
+				*(list **)fwds = list_nodeadd(*(list **)fwds, address, strlen(address) + 1);
 				free(endptr);
 			}
 
 			trace(TRACE_DEBUG,
 			      "%s,%s: adding [%s] to deliver_to address",__FILE__,__func__,
 			      address);
-			list_freelist(&templist.start);
+			list_freelist(templist1);
 			return 1;
 		} else {
 			trace(TRACE_DEBUG,
 			      "%s,%s: user [%s] not in aliases table",__FILE__,__func__,
 			      address);
-			list_freelist(&templist.start);
+			list_freelist(templist1);
 			return 0;
 		}
 	}
@@ -1021,19 +981,17 @@
 	trace(TRACE_DEBUG, "%s,%s: into checking loop",__FILE__,__func__);
 
 	/* do the first entry here */
-	tempelem1 = list_getstart(&templist);
+	templist1 = list_first(templist1);
 
-	count1 = templist.total_nodes;
+	count1 = list_totalnodes(templist);
 	for (c1 = 0; c1 < count1; c1++) {
 		int fwdsave = 1;
 		int fwdmaysave = 1;
-		tempelem2 = list_getstart((struct list *) tempelem1->data);
-		count2 = ((struct list *) tempelem1->data)->total_nodes;
+		templist2 = templist1->data;
+		count2 = list_totalnodes(templist2);
 		for (c2 = 0; c2 < count2; c2++) {
-			tempelem3 =
-			    list_getstart((struct list *) tempelem2->data);
-			count3 =
-			    ((struct list *) tempelem2->data)->total_nodes;
+			templist3 = templist2->data;
+			count3 = list_totalnodes(templist3);
 			for (c3 = 0; c3 < count3; c3++) {
 // here begins the meat
 				/* Note that the fields are in *reverse*
@@ -1046,16 +1004,15 @@
 						trace(TRACE_DEBUG,
 						      "%s,%s: checking user %s to %s",__FILE__,__func__,
 						      address,
-						      (char *) tempelem3->
+						      (char *) templist3->
 						      data);
 						occurences +=
-						    auth_check_user_ext((char *) tempelem3->data, userids, fwds, 1);
+						    auth_check_user_ext((char *) templist3->data, userids, fwds, 1);
 					} else {
 						trace(TRACE_DEBUG,
 						      "%s,%s: not checking user %s to %s due to fwdsave=0",__FILE__,__func__,
 						      address,
-						      (char *) tempelem3->
-						      data);
+						      (char *) templist3->data);
 					}
 				} else if (3 == c2) {
 					/* do a recursive search for deliver_to */
@@ -1064,27 +1021,18 @@
 					trace(TRACE_DEBUG,
 					      "%s,%s: checking user %s to %s",__FILE__,__func__,
 					      address,
-					      (char *) tempelem3->data);
+					      (char *) templist3->data);
 					occurences +=
-					    auth_check_user_ext((char *)
-								tempelem3->
-								data,
-								userids,
-								fwds, -2);
+					    auth_check_user_ext((char *)templist3->data, userids, fwds, -2);
 				} else if (2 == c2) {
 					/* do a recursive search for deliver_to */
 					trace(TRACE_DEBUG,
 					      "%s,%s: looks like a forwarding dn",__FILE__,__func__);
 					trace(TRACE_DEBUG,
 					      "%s,%s: checking user %s to %s",__FILE__,__func__,
-					      address,
-					      (char *) tempelem3->data);
+					      address, (char *) templist3->data);
 					occurences +=
-					    auth_check_user_ext((char *)
-								tempelem3->
-								data,
-								userids,
-								fwds, -2);
+					    auth_check_user_ext((char *) templist3->data, userids, fwds, -2);
 					/* if the user does not have a forward, their fwdsave will be false
 					 * but logically, it is true: "save, then forward to nowhere"
 					 * so here we make sure that before we don't deliver we check:
@@ -1098,16 +1046,10 @@
 					      "%s,%s: looks like a forwarding state",__FILE__,__func__);
 					trace(TRACE_DEBUG,
 					      "%s,%s: checking user %s to %s",__FILE__,__func__,
-					      address,
-					      (char *) tempelem3->data);
-					if (0 ==
-					    strcasecmp((char *) tempelem3->
-						       data, "true"))
+					      address, (char *) templist3->data);
+					if (0 == strcasecmp((char *) templist3->data, "true"))
 						fwdmaysave = 1;
-					else if (0 ==
-						 strcasecmp((char *)
-							    tempelem3->
-							    data, "false"))
+					else if (0 == strcasecmp((char *)templist3->data, "false"))
 						fwdmaysave = 0;
 				} else if (0 == c2) {
 					/* do a recursive search for deliver_to */
@@ -1115,38 +1057,20 @@
 					      "%s,%s: looks like a forwarding target",__FILE__,__func__);
 					/* rip the prefix off of the result */
 					{
-						char target
-						    [AUTH_QUERY_SIZE];
+						char target[AUTH_QUERY_SIZE];
 						/* I am much happier now that this is case insensitive :-)
 						 * albeit at the cost of complication and uglification...
 						 * perhaps this could be made into a separate function... */
-						if (0 ==
-						    strncasecmp((char *)
-								tempelem3->
-								data,
-								_ldap_cfg.
-								fwdtargetprefix,
-								strlen
-								(_ldap_cfg.
-								 fwdtargetprefix)))
+						if (0 == strncasecmp((char *)templist3->data, _ldap_cfg.fwdtargetprefix,
+								strlen(_ldap_cfg.fwdtargetprefix)))
 						{
 							/* Offset the pointer by the length of the prefix to skip */
-							sscanf((char *)
-							       tempelem3->
-							       data +
-							       strlen
-							       (_ldap_cfg.
-								fwdtargetprefix),
-							       " %s ",
-							       &target[0]);
+							sscanf((char *)templist3->data + strlen(_ldap_cfg.fwdtargetprefix),
+							       " %s ", &target[0]);
 						} else {
 							/* The prefix wasn't in there, so just use what we got */
-							snprintf(target,
-								 AUTH_QUERY_SIZE,
-								 "%s",
-								 (char *)
-								 tempelem3->
-								 data);
+							snprintf(target, AUTH_QUERY_SIZE, "%s",
+								 (char *)templist3->data);
 						}
 						trace(TRACE_DEBUG,
 						      "%s,%s: checking user %s to %s",__FILE__,__func__,
@@ -1157,17 +1081,15 @@
 							     + 1);
 					}
 				}
-				tempelem3 = tempelem3->nextnode;
+				templist3 = list_next(templist3);
 			}
-			list_freelist(&((struct list *) tempelem2->data)->
-				      start);
-			tempelem2 = tempelem2->nextnode;
+			list_freelist(templist3);
+			templist2 = list_next(templist2);
 		}
-		list_freelist(&((struct list *) tempelem1->data)->start);
-		tempelem1 = tempelem1->nextnode;
+		list_freelist(templist2);
+		templist1 = list_next(templist1);
 	}
-	list_freelist(&templist.start);
-
+	list_freelist(templist1);
 	trace(TRACE_DEBUG,
 	      "%s,%s: executing query, checks [%d]",__FILE__,__func__,
 	      checks);
@@ -1976,7 +1898,7 @@
  * \attention aliases list needs to be empty. Method calls list_init()
  *            which sets list->start to NULL.
  */
-int auth_get_user_aliases(u64_t user_idnr, struct list *aliases)
+int auth_get_user_aliases(u64_t user_idnr, list *aliases)
 {
 	return 0;
 }
@@ -2047,7 +1969,7 @@
 //  {
 //  int c1, c2, c3;
 //  int count1, count2, count3;
-//  struct list templist;
+//  list templist;
 //  struct element *tempelem1, *tempelem2, *tempelem3;
 //
 //  // do the first entry here 
@@ -2058,13 +1980,13 @@
 //  printf( "retlist has %d nodes\n", retlist->total_nodes );
 //  for( c1 = 0; c1 < count1; c1++ )
 //    {
-//      tempelem2 = list_getstart( (struct list *)tempelem1->data );
-//      count2 = ((struct list *)tempelem1->data)->total_nodes;
+//      tempelem2 = list_getstart( (list *)tempelem1->data );
+//      count2 = ((list *)tempelem1->data)->total_nodes;
 //      for( c2 = 0; c2 < count2; c2++ )
 //        {
 //          //if( tempelem2 )
-//          tempelem3 = list_getstart( (struct list *)tempelem2->data );
-//          count3 = ((struct list *)tempelem2->data)->total_nodes;
+//          tempelem3 = list_getstart( (list *)tempelem2->data );
+//          count3 = ((list *)tempelem2->data)->total_nodes;
 //          for( c3 = 0; c3 < count3; c3++ )
 //            {
 //              printf( "I've got %s\n", tempelem3->data );
diff -urNad dbmail-2.1/auth/authsql.c /tmp/dpep.MIMNv7/dbmail-2.1/auth/authsql.c
--- dbmail-2.1/auth/authsql.c	2004-11-04 12:03:02.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/auth/authsql.c	2004-11-16 09:29:02.000000000 +0100
@@ -128,19 +128,11 @@
 	return 1;
 }
 
-int auth_get_known_users(struct list *users)
+int auth_get_known_users(list *users)
 {
 	u64_t i;
 	const char *query_result;
 
-	if (!users) {
-		trace(TRACE_ERROR, "%s,%s: got a NULL pointer as argument",
-		      __FILE__, __func__);
-		return -2;
-	}
-
-	list_init(users);
-
 	/* do a inverted (DESC) query because adding the names to the
 	 * final list inverts again */
 	snprintf(__auth_query_data, AUTH_QUERY_SIZE,
@@ -155,10 +147,9 @@
 	if (db_num_rows() > 0) {
 		for (i = 0; i < (unsigned) db_num_rows(); i++) {
 			query_result = db_get_result(i, 0);
-			if (!list_nodeadd
-			    (users, query_result,
-			     strlen(query_result) + 1)) {
-				list_freelist(&users->start);
+			trace(TRACE_DEBUG, "%s,%s: got user: [%s]", __FILE__, __func__, (char *)query_result);
+			if (! (*(list **)users = list_nodeadd (*(list **)users, (char *)query_result, strlen(query_result) + 1))) {
+				list_freelist(users);
 				return -2;
 			}
 		}
@@ -267,7 +258,7 @@
 	return __auth_encryption_desc_string;
 }
 
-int auth_check_user(const char *username, struct list *userids, int checks)
+int auth_check_user(const char *username, list *userids, int checks)
 {
 	int occurences = 0;
 	int r;
@@ -318,8 +309,7 @@
 			/* found the last one, this is the deliver to
 			 * but checks needs to be bigger then 0 because
 			 * else it could be the first query failure */
-			list_nodeadd(userids, username,
-				     strlen(username) + 1);
+			*(list **)userids = list_nodeadd(*(list **)userids, (char *)username, strlen(username) + 1);
 			trace(TRACE_DEBUG,
 			      "%s,%s: adding [%s] to deliver_to address",
 			      __FILE__, __func__, username);
@@ -357,9 +347,8 @@
 				if (checks > 0)
 					return -1;	/* still in recursive call */
 
-				if (userids->start) {
-					list_freelist(&userids->start);
-					userids->total_nodes = 0;
+				if (userids) {
+					list_freelist(userids);
 				}
 
 				return 0;	/* report to calling routine: no results */
@@ -374,8 +363,8 @@
 	return occurences;
 }
 
-int auth_check_user_ext(const char *username, struct list *userids,
-			struct list *fwds, int checks)
+int auth_check_user_ext(const char *username, list *userids,
+			list *fwds, int checks)
 {
 	int occurences = 0;
 	void *saveres;
@@ -422,11 +411,10 @@
 			id = strtoull(username, &endptr, 10);
 
 			if (*endptr == 0)
-				list_nodeadd(userids, &id, sizeof(id));
+				*(list **)userids = list_nodeadd(*(list **)userids, &id, sizeof(id));
 			/* numeric deliver-to --> this is a userid */
 			else
-				list_nodeadd(fwds, username,
-					     strlen(username) + 1);
+				*(list **)fwds = list_nodeadd(*(list **)fwds, (char *)username, strlen(username) + 1);
 
 			trace(TRACE_DEBUG,
 			      "%s,%s: adding [%s] to deliver_to address",
@@ -1213,7 +1201,7 @@
 }
 
 
-int auth_get_user_aliases(u64_t user_idnr, struct list *aliases)
+int auth_get_user_aliases(u64_t user_idnr, list *aliases)
 {
 	int i, n;
 	const char *query_result;
@@ -1241,11 +1229,9 @@
 	n = db_num_rows();
 	for (i = 0; i < n; i++) {
 		query_result = db_get_result(i, 0);
-		if (!query_result || !list_nodeadd(aliases,
-						   query_result,
-						   strlen(query_result) +
-						   1)) {
-			list_freelist(&aliases->start);
+		if (!query_result || 
+				!( *(list **)aliases = list_nodeadd(*(list **)aliases, (char *)query_result, strlen(query_result) + 1))) {
+			list_freelist(aliases);
 			db_free_result();
 			return -2;
 		}
diff -urNad dbmail-2.1/auth.h /tmp/dpep.MIMNv7/dbmail-2.1/auth.h
--- dbmail-2.1/auth.h	2004-09-10 10:02:55.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/auth.h	2004-11-16 09:29:02.000000000 +0100
@@ -80,7 +80,7 @@
  *    -  0 on success
  * \attention caller should free list
  */
-int auth_get_known_users(struct list *users);
+int auth_get_known_users(list *users);
 
 /**
  * \brief get client_id for a user
@@ -127,7 +127,7 @@
  * be set to -1 when called!
  * \return number of deliver_to addresses found
  */
-int auth_check_user(const char *username, struct list *userids,
+int auth_check_user(const char *username, list *userids,
 		    int checks);
 /**
  * \brief as auth_check_user() but adds the numeric ID of the user found to
@@ -138,8 +138,8 @@
  * \param checks used internally, \b should be -1 on call
  * \return number of deliver_to addresses found
  */
-int auth_check_user_ext(const char *username, struct list *userids,
-			struct list *fwds, int checks);
+int auth_check_user_ext(const char *username, list *userids,
+			list *fwds, int checks);
 /**
  * \brief add a new user to the database (whichever type of database is 
  * implemented)
@@ -274,7 +274,7 @@
  * \attention aliases list needs to be empty. Method calls list_init()
  *            which sets list->start to NULL.
  */
-int auth_get_user_aliases(u64_t user_idnr, struct list *aliases);
+int auth_get_user_aliases(u64_t user_idnr, list *aliases);
 /**
  * \brief add an alias for a user
  * \param user_idnr user's id
diff -urNad dbmail-2.1/config.c /tmp/dpep.MIMNv7/dbmail-2.1/config.c
--- dbmail-2.1/config.c	2004-09-20 15:45:05.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/config.c	2004-11-16 09:29:02.000000000 +0100
@@ -43,13 +43,13 @@
 /* list of all config lists. Every item in this list holds a list for
  * the specific service [SERVICE NAME] 
  */
-static struct list config_list;
+static list * config_list;
 
 /**
  */
 struct service_config_list {
 	char *service_name;
-	struct list *config_items;
+	list *config_items;
 };
 
 /**
@@ -58,7 +58,7 @@
  * \param[in] config_items list of configuration items for a service
  * \param[out] value will hold value of configuration item
  */
-static int GetConfigValueConfigList(const field_t name, struct list *cfg_items,
+static int GetConfigValueConfigList(const field_t name, list *cfg_items,
 				    field_t value);
 /*
  * ReadConfig()
@@ -78,26 +78,16 @@
 int ReadConfig(const char *serviceName, const char *cfilename)
 {
 	struct service_config_list *service_config;
-	item_t item;
+	item_t * item;
 	char line[LINESIZE], *tmp, *value, service[LINESIZE];
 	FILE *cfile = NULL;
 	int serviceFound = 0, isCommentline;
 
 	trace(TRACE_DEBUG, "ReadConfig(): starting procedure");
 
-	if (!(service_config = 
-	      my_malloc(sizeof(struct service_config_list)))) {
-		trace(CONFIG_ERROR_LEVEL, "%s,%s: error allocating memory "
-		      "for config list", __FILE__, __func__);
-		return -1;
-	}
-	if (!(service_config->config_items = 
-	      my_malloc(sizeof(struct list)))) {
-		trace(TRACE_ERROR, "%s,%s: unable to allocate memory "
-		      "for config items", __FILE__, __func__);
-		my_free(service_config);
-		return -1;
-	}
+	service_config = (struct service_config_list *)my_malloc(sizeof(struct service_config_list));
+	memset(service_config, '\0', sizeof(struct service_config_list));
+
 	service_config->service_name = strdup(serviceName);
 
 	(void) snprintf(service, LINESIZE, "[%s]", serviceName);
@@ -108,14 +98,17 @@
 		trace(CONFIG_ERROR_LEVEL,
 		      "ReadConfig(): could not open config file [%s]",
 		      cfilename);
-		list_freelist(&(service_config->config_items->start));
-		my_free(service_config->config_items);
+		list_freelist(service_config->config_items);
 		my_free(service_config->service_name);
-		my_free(service_config);
+	  my_free(service_config);
 		return -1;
 	}
 
+	item = (item_t *)my_malloc(sizeof(item_t));
+	memset(item, '\0', sizeof(item_t));
+
 	do {
+	  memset(line, '\0', LINESIZE);
 		if (fgets(line, LINESIZE, cfile) == NULL)
 			break;
 
@@ -132,11 +125,11 @@
 
 			trace(TRACE_DEBUG, "ReadConfig(): found %s tag",
 			      service);
-			memset(&item, 0, sizeof(item));
 
 			while (1) {
 				isCommentline = 0;
 
+				memset(line, '\0', LINESIZE);
 				if (fgets(line, LINESIZE, cfile) == NULL)
 					break;
 
@@ -173,101 +166,134 @@
 				*tmp = '\0';
 				value = tmp + 1;
 
-				strncpy(item.name, line, FIELDSIZE);
-				strncpy(item.value, value, FIELDSIZE);
+				strncpy(item->name, line, FIELDSIZE);
+				strncpy(item->value, value, FIELDSIZE);
 
-				if (!list_nodeadd
-				    (service_config->config_items, &item, 
-				     sizeof(item))) {
-					trace(CONFIG_ERROR_LEVEL,
-					      "ReadConfig(): could not add node");
-					list_freelist(
-						&(service_config->
-						  config_items->start));
-					my_free(service_config->config_items);
+				if (!(service_config->config_items = list_nodeadd (service_config->config_items, item, sizeof(item_t)))) {
+					trace(CONFIG_ERROR_LEVEL, "ReadConfig(): could not add node");
+					list_freelist(service_config->config_items);
 					my_free(service_config->service_name);
 					my_free(service_config);
+					my_free(item);
 					return -1;
 				}
 
-				trace(TRACE_DEBUG,
-				      "ReadConfig(): item [%s] value [%s] added",
-				      item.name, item.value);
+				trace(TRACE_DEBUG, "ReadConfig(): item [%s] value [%s] added", item->name, item->value);
+				//fprintf(stderr, "ReadConfig(): service %s item [%s] value [%s] added\n", service, item->name, item->value);
 			}
-			trace(TRACE_DEBUG,
-			      "ReadConfig(): service %s added", service);
+			trace(TRACE_DEBUG, "ReadConfig(): service %s added", service);
 		}
 
 		/* skip otherwise */
 	} while (!serviceFound);
 
-	trace(TRACE_DEBUG,
-	      "ReadConfig(): config for %s read, found [%ld] config_items",
-	      service, service_config->config_items->total_nodes);
+	my_free(item); 
+
+	trace(TRACE_DEBUG, "ReadConfig(): config for %s read, found [%ld] config_items",
+	      service, list_totalnodes(service_config->config_items));
 	if (fclose(cfile) != 0) 
 		trace(TRACE_ERROR, "%s,%s: error closing file: [%s]",
 		      __FILE__, __func__, strerror(errno));
-	
-	if (!list_nodeadd(&config_list, service_config, 
-			  sizeof(struct service_config_list))) {
+
+	if (!(config_list = list_nodeadd(config_list, service_config, 
+			  sizeof(struct service_config_list)))) {
 		trace(CONFIG_ERROR_LEVEL,
 		      "%s,%s: could not add config list",
 		      __FILE__, __func__);
-		list_freelist(&(service_config->config_items->start));
-		my_free(service_config->config_items);
+		list_freelist(service_config->config_items);
 		my_free(service_config->service_name);
 		my_free(service_config);
 		return -1;
 	}
-	/* list_nodeadd makes a shallow copy of the service_config_list 
-	   struct. So, we need to clean that up.*/
 	my_free(service_config);
 	
 	return 0;
 }
 
+void _free_service_config_items (gpointer data, gpointer temp UNUSED)
+{
+	item_t * item;
+	item = (item_t *)data;
+	if(item){	
+	 my_free(item);
+  }
+}
+
+void _free_service_config (gpointer data, gpointer temp UNUSED)
+{
+	struct service_config_list *service_config;
+	service_config = (struct service_config_list *)data;
+	if(service_config){
+	 list_foreach(service_config->config_items, (GFunc)_free_service_config_items, NULL);
+	 list_freelist(service_config->config_items);
+	 my_free(service_config->service_name);
+	 my_free(service_config);
+	}
+}
+
 void config_free()
 {
-	struct element *el;
-	struct element *next_el;
-	struct service_config_list *scl;
-	
-	/* first free all "sublists" */
-	el = list_getstart(&config_list);
-	while(el) {
-		scl = (struct service_config_list *) el->data;
-		next_el = el->nextnode;
-		list_freelist(&(scl->config_items->start));
-		my_free(scl->config_items);
-		my_free(scl->service_name);
-		list_nodedel(&config_list, el->data);
-		el = next_el;
+	list_foreach(config_list, (GFunc)_free_service_config, NULL);
+	list_freelist(config_list);
+}
+
+int _getconfigvalue(gpointer data, gpointer temp)
+{
+	item_t *item1, *item2;
+	item1 = (item_t *)data;
+	item2 = (item_t *)temp;
+	if(item1 && item2) {
+		if(!strcasecmp(item1->name, item2->name)){
+		 return 0;
+    }
 	}
-	/* free global list */
-	list_freelist(&(config_list.start));
+	return 1;
+}
+
+int _find_service_configlist (gpointer data, gpointer temp)
+{
+  struct service_config_list *service_config, *match;
+  service_config = (struct service_config_list *)data;
+	match = (struct service_config_list *)temp;
+
+  if(service_config && match){
+	 if(!strcmp(service_config->service_name, match->service_name)){
+		return 0;
+   }
+  }
+	return 1;
 }
 
 int GetConfigValue(const field_t field_name, const char *service_name, 
 		   field_t value) {
-	struct element *el;
-	struct service_config_list *scl;
+	list *tlist;
+	struct service_config_list scl, *sclp;
+	item_t tmp, *item;
 
-	el = list_getstart(&config_list);
-	while(el) {
-		scl = (struct service_config_list *) el->data;
-		if (!scl || strlen(scl->service_name) == 0) 
-			trace(TRACE_INFO, "%s,%s: NULL config_list on "
-			      "config list", __FILE__, __func__);
-		else {
-			if (strcmp(scl->service_name, service_name) == 0) {
-				/* found correct list */
-				GetConfigValueConfigList(field_name,
-							 scl->config_items,
-							 value);
-				return 1;
-			} 
+	scl.service_name = (char *)service_name;
+
+	tlist = list_find_custom(config_list, &scl, (GCompareFunc)_find_service_configlist);
+
+	if(!tlist){
+	 trace(TRACE_INFO, "%s,%s: NULL config_list on "
+    "config list", __FILE__, __func__);
+	}else{
+	  sclp = (struct service_config_list *)tlist->data;
+	  memset(value, '\0', sizeof(field_t));
+		trace(TRACE_DEBUG, "GetConfigValue(): searching value for config item [%s]", field_name);
+
+		memset(&tmp,'\0', sizeof(item_t));
+		memcpy(tmp.name,field_name,sizeof(field_t));
+
+		if((tlist = list_find_custom(sclp->config_items,&tmp,(GCompareFunc)_getconfigvalue)) == NULL) {
+		 trace(TRACE_DEBUG, "GetConfigValue(): item not found");
+		}else{
+		 item = (item_t *)tlist->data;
+		 trace(TRACE_DEBUG, "GetConfigValue(): found value [%s]", item->value);
+	   strncpy(value, item->value, FIELDSIZE);
 		}
-		el = el->nextnode;
+		//fprintf(stderr, "getconfigvalue '%s', field '%s', service_name '%s'\n", value, field_name,service_name);
+		return 1;
 	}
 	
 	trace(TRACE_DEBUG, "%s,%s config for service %s not found",
@@ -275,47 +301,9 @@
 	return 0;
 }
 			
-int GetConfigValueConfigList(const field_t name, struct list *config_items,
-			     field_t value)
+int GetConfigValueConfigList(const field_t name UNUSED, list *config_items UNUSED,
+			     field_t value UNUSED)
 {
-	item_t *item;
-	struct element *el;
-
-	assert(config_items);
-
-	value[0] = '\0';
-	
-	trace(TRACE_DEBUG,
-	      "GetConfigValue(): searching value for config item [%s]",
-	      name);
-
-	el = list_getstart(config_items);
-	while (el) {
-		item = (item_t *) el->data;
-
-		if (!item || strlen(item->name) == 0 || 
-		    strlen(item->value) == 0) {
-			trace(TRACE_INFO,
-			      "GetConfigValue(): NULL item %s in item-list",
-			      item ? (strlen(item->name) > 0?
-				      " value" : " name") : "");
-
-			el = el->nextnode;
-			continue;
-		}
-
-		if (strcasecmp(item->name, name) == 0) {
-			trace(TRACE_DEBUG,
-			      "GetConfigValue(): found value [%s]",
-			      item->value);
-			strncpy(value, item->value, FIELDSIZE);
-			return 0;
-		}
-
-		el = el->nextnode;
-	}
-
-	trace(TRACE_DEBUG, "GetConfigValue(): item not found");
 	return 0;
 }
 
@@ -323,6 +311,7 @@
 {
 	field_t val;
 
+	//fprintf(stderr, "calling GetConfigValue for trace_level\n");
 	if (GetConfigValue("trace_level", service_name, val) < 0)
 		trace(TRACE_FATAL, "%s,%s: error getting config!",
 		      __FILE__, __func__);
@@ -357,10 +346,8 @@
 
 	switch (GetConfigValue("table_prefix", "DBMAIL", db_params->pfx) < 0) {
 	case -1:
-		trace(TRACE_FATAL, "%s,%s: error getting config!",
+		trace(TRACE_ERROR, "%s,%s: error getting config!",
 		      __FILE__, __func__);
-		break;
-	case 0:
 		/* only default to DEFAULT_DBPFX if there is no
 		   table_prefix mentioned in config file, not when it's 
 		   "", which should be possible (in fact, that's what 
diff -urNad dbmail-2.1/db.c /tmp/dpep.MIMNv7/dbmail-2.1/db.c
--- dbmail-2.1/db.c	2004-11-16 09:14:52.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/db.c	2004-11-16 09:29:02.000000000 +0100
@@ -492,7 +492,7 @@
 	return n;
 }
 
-int db_get_sievescript_listall(u64_t user_idnr, struct list *scriptlist)
+int db_get_sievescript_listall(u64_t user_idnr, list *scriptlist)
 {
 	int i,n;
 	struct ssinfo *info;
@@ -1171,7 +1171,7 @@
 	return result;
 }
 
-int db_icheck_messageblks(struct list *lost_list)
+int db_icheck_messageblks(list *lost_list)
 {
 	const char *query_result;
 	u64_t messageblk_idnr;
@@ -1214,12 +1214,10 @@
 
 		trace(TRACE_INFO, "%s,%s: found lost block id [%llu]",
 		      __FILE__, __func__, messageblk_idnr);
-		if (!list_nodeadd
-		    (lost_list, &messageblk_idnr, sizeof(u64_t))) {
-			trace(TRACE_ERROR,
-			      "%s,%s: could not add block to list",
+		if (! (*(list **)lost_list = list_nodeadd(*(list **)lost_list, &messageblk_idnr, sizeof(u64_t)))) {
+			trace(TRACE_ERROR, "%s,%s: could not add block to list",
 			      __FILE__, __func__);
-			list_freelist(&lost_list->start);
+			list_freelist(lost_list);
 			db_free_result();
 			return -2;
 		}
@@ -1228,7 +1226,7 @@
 	return 0;
 }
 
-int db_icheck_messages(struct list *lost_list)
+int db_icheck_messages(list *lost_list)
 {
 	u64_t message_idnr;
 	const char *query_result;
@@ -1266,11 +1264,11 @@
 
 		trace(TRACE_INFO, "%s,%s: found lost message id [%llu]",
 		      __FILE__, __func__, message_idnr);
-		if (!list_nodeadd(lost_list, &message_idnr, sizeof(u64_t))) {
+		if (!(*(list **)lost_list = list_nodeadd(*(list **)lost_list, &message_idnr, sizeof(u64_t)))) {
 			trace(TRACE_ERROR,
 			      "%s,%s: could not add message to list",
 			      __FILE__, __func__);
-			list_freelist(&lost_list->start);
+			list_freelist(lost_list);
 			db_free_result();
 			return -2;
 		}
@@ -1279,7 +1277,7 @@
 	return 0;
 }
 
-int db_icheck_mailboxes(struct list *lost_list)
+int db_icheck_mailboxes(list *lost_list)
 {
 	u64_t mailbox_idnr;
 	const char *query_result;
@@ -1317,11 +1315,11 @@
 
 		trace(TRACE_INFO, "%s,%s: found lost mailbox id [%llu]",
 		      __FILE__, __func__, mailbox_idnr);
-		if (!list_nodeadd(lost_list, &mailbox_idnr, sizeof(u64_t))) {
+		if (!(*(list **)lost_list = list_nodeadd(*(list **)lost_list, &mailbox_idnr, sizeof(u64_t)))) {
 			trace(TRACE_ERROR,
 			      "%s,%s: could not add mailbox to list",
 			      __FILE__, __func__);
-			list_freelist(&lost_list->start);
+			list_freelist(lost_list);
 			db_free_result();
 			return -2;
 		}
@@ -1330,7 +1328,7 @@
 	return 0;
 }
 
-int db_icheck_null_physmessages(struct list *lost_list)
+int db_icheck_null_physmessages(list *lost_list)
 {
 	u64_t physmessage_id;
 	const char *result_string;
@@ -1368,12 +1366,11 @@
 		trace(TRACE_INFO,
 		      "%s,%s: found empty physmessage_id [%llu]", __FILE__,
 		      __func__, physmessage_id);
-		if (!list_nodeadd
-		    (lost_list, &physmessage_id, sizeof(u64_t))) {
+		if (!(*(list **)lost_list = list_nodeadd(*(list **)lost_list, &physmessage_id, sizeof(u64_t)))) {
 			trace(TRACE_ERROR,
 			      "%s,%s: could not add physmessage "
 			      "to list", __FILE__, __func__);
-			list_freelist(&lost_list->start);
+			list_freelist(lost_list);
 			db_free_result();
 			return -2;
 		}
@@ -1382,7 +1379,7 @@
 	return 0;
 }
 
-int db_icheck_null_messages(struct list *lost_list)
+int db_icheck_null_messages(list *lost_list)
 {
 	u64_t message_idnr;
 	const char *query_result;
@@ -1419,11 +1416,11 @@
 
 		trace(TRACE_INFO, "%s,%s: found empty message id [%llu]",
 		      __FILE__, __func__, message_idnr);
-		if (!list_nodeadd(lost_list, &message_idnr, sizeof(u64_t))) {
+		if (!(*(list **)lost_list = list_nodeadd(*(list **)lost_list, &message_idnr, sizeof(u64_t)))) {
 			trace(TRACE_ERROR,
 			      "%s,%s: could not add message to list",
 			      __FILE__, __func__);
-			list_freelist(&lost_list->start);
+			list_freelist(lost_list);
 			db_free_result();
 			return -2;
 		}
@@ -1799,7 +1796,7 @@
 	const char *query_result;
 	u64_t inbox_mailbox_idnr;
 
-	list_init(&session_ptr->messagelst);
+	list_init(session_ptr->messagelst);
 
 	if (db_findmailbox("INBOX", user_idnr, &inbox_mailbox_idnr) <= 0) {
 		trace(TRACE_ERROR, "%s,%s: error finding mailbox_idnr of "
@@ -1860,7 +1857,7 @@
 		/* descending to create inverted list */
 		message_counter--;
 		tmpmessage.messageid = (u64_t) message_counter;
-		list_nodeadd(&session_ptr->messagelst, &tmpmessage,
+		session_ptr->messagelst = list_nodeadd(session_ptr->messagelst, &tmpmessage,
 			     sizeof(tmpmessage));
 	}
 
@@ -1884,38 +1881,30 @@
 	session_ptr->virtual_totalsize = 0;
 	session_ptr->totalmessages = 0;
 	session_ptr->virtual_totalmessages = 0;
-	list_freelist(&(session_ptr->messagelst.start));
+	list_freelist(session_ptr->messagelst);
 }
 
 int db_update_pop(PopSession_t * session_ptr)
 {
-	struct element *tmpelement;
 	u64_t user_idnr = 0;
 
 	/* get first element in list */
-	tmpelement = list_getstart(&session_ptr->messagelst);
+	list *tlist = list_first(session_ptr->messagelst);
 
-	while (tmpelement != NULL) {
+	while (tlist) {
 		/* check if they need an update in the database */
-		if (((struct message *) tmpelement->data)->
-		    virtual_messagestatus !=
-		    ((struct message *) tmpelement->data)->messagestatus) {
+		if (((struct message *) tlist->data)->virtual_messagestatus != ((struct message *) tlist->data)->messagestatus) {
 			/* use one message to get the user_idnr that goes with the
 			   messages */
 			if (user_idnr == 0)
-				user_idnr =
-				    db_get_useridnr(((struct message *)
-						     tmpelement->data)->
-						    realmessageid);
+				user_idnr = db_get_useridnr(((struct message *)tlist->data)->realmessageid);
 
 			/* yes they need an update, do the query */
 			snprintf(query, DEF_QUERYSIZE,
 				 "UPDATE %smessages set status='%d' WHERE "
 				 "message_idnr='%llu' AND status < '%d'",DBPFX,
-				 ((struct message *)
-				  tmpelement->data)->virtual_messagestatus,
-				 ((struct message *) tmpelement->data)->
-				 realmessageid, MESSAGE_STATUS_DELETE);
+				 ((struct message *)tlist->data)->virtual_messagestatus,
+				 ((struct message *)tlist->data)->realmessageid, MESSAGE_STATUS_DELETE);
 
 			/* FIXME: a message could be deleted already if it has been accessed
 			 * by another interface and be deleted by sysop
@@ -1931,7 +1920,7 @@
 				return -1;
 			}
 		}
-		tmpelement = tmpelement->nextnode;
+		tlist = list_next(tlist);
 	}
 
 	/* because the status of some messages might have changed (for instance
@@ -3549,7 +3538,84 @@
 	return 1;
 }
 
-int db_get_main_header(u64_t msg_idnr, struct list *hdrlist)
+int db_get_msginfo_range(u64_t msg_idnr_low, u64_t msg_idnr_high,
+			 u64_t mailbox_idnr, int get_flags,
+			 int get_internaldate,
+			 int get_rfcsize, int get_msg_idnr,
+			 msginfo_t ** result, unsigned *resultsetlen)
+{
+	unsigned nrows, i, j;
+	const char *query_result;
+	char *to_char_str;
+	*result = 0;
+	*resultsetlen = 0;
+
+	db_free_result();
+
+	to_char_str = date2char_str("internal_date");
+	snprintf(query, DEF_QUERYSIZE,
+		 "SELECT seen_flag, answered_flag, deleted_flag, flagged_flag, "
+		 "draft_flag, recent_flag, %s, rfcsize, message_idnr "
+		 "FROM %smessages msg, %sphysmessage pm "
+		 "WHERE pm.id = msg.physmessage_id "
+		 "AND message_idnr BETWEEN '%llu' AND '%llu' "
+		 "AND mailbox_idnr = '%llu' AND status < '%d' "
+		 "ORDER BY message_idnr ASC",to_char_str,DBPFX,DBPFX,
+		 msg_idnr_low, msg_idnr_high, mailbox_idnr,
+		 MESSAGE_STATUS_DELETE);
+	my_free(to_char_str);
+
+	if (db_query(query) == -1) {
+		trace(TRACE_ERROR, "%s,%s: could not select message",
+		      __FILE__, __func__);
+		return (-1);
+	}
+
+	if ((nrows = db_num_rows()) == 0) {
+		db_free_result();
+		return 0;
+	}
+
+	*result = (msginfo_t *) my_malloc(nrows * sizeof(msginfo_t));
+	if (!(*result)) {
+		trace(TRACE_ERROR, "%s,%s: out of memory", __FILE__,
+		      __func__);
+		db_free_result();
+		return -2;
+	}
+
+	memset(*result, 0, nrows * sizeof(msginfo_t));
+
+	for (i = 0; i < nrows; i++) {
+		if (get_flags) {
+			for (j = 0; j < IMAP_NFLAGS; j++) {
+				(*result)[i].flags[j] = db_get_result_bool(i, j);
+			}
+		}
+
+		if (get_internaldate) {
+			query_result = db_get_result(i, IMAP_NFLAGS);
+			strncpy((*result)[i].internaldate,
+				(query_result) ? query_result :
+				"1970-01-01 00:00:01",
+				IMAP_INTERNALDATE_LEN);
+		}
+		if (get_rfcsize) {
+			(*result)[i].rfcsize =
+			    db_get_result_u64(i, IMAP_NFLAGS + 1);
+		}
+		if (get_msg_idnr) {
+			(*result)[i].uid =
+			    db_get_result_u64(i, IMAP_NFLAGS + 2);
+		}
+	}
+	db_free_result();
+
+	*resultsetlen = nrows;
+	return 0;
+}
+
+int db_get_main_header(u64_t msg_idnr, list *hdrlist)
 {
 	const char *query_result;
 	u64_t dummy = 0, sizedummy = 0;
@@ -3558,8 +3624,7 @@
 	if (!hdrlist)
 		return 0;
 
-	if (hdrlist->start)
-		list_freelist(&hdrlist->start);
+	list_freelist(hdrlist);
 
 	list_init(hdrlist);
 
@@ -3603,8 +3668,8 @@
 		trace(TRACE_ERROR,
 		      "%s,%s: error parsing header of message [%llu]",
 		      __FILE__, __func__, msg_idnr);
-		if (hdrlist->start) {
-			list_freelist(&hdrlist->start);
+		if (hdrlist) {
+			list_freelist(hdrlist);
 			list_init(hdrlist);
 		}
 		return -3;
@@ -3614,8 +3679,8 @@
 		/* out of memory */
 		trace(TRACE_ERROR, "%s,%s: out of memory", __FILE__,
 		      __func__);
-		if (hdrlist->start) {
-			list_freelist(&hdrlist->start);
+		if (hdrlist) {
+			list_freelist(hdrlist);
 			list_init(hdrlist);
 		}
 		return -2;
@@ -3801,7 +3866,7 @@
 	return 1;
 }
 
-int db_acl_get_identifier(u64_t mboxid, struct list *identifier_list)
+int db_acl_get_identifier(u64_t mboxid, list *identifier_list)
 {
 	unsigned i, n;
 	const char *result_string;
@@ -3828,10 +3893,7 @@
 		result_string = db_get_result(i, 0);
 		trace(TRACE_DEBUG, "%s,%s: adding %s to identifier list",
 		      __FILE__, __func__, result_string);
-		if (!result_string || !list_nodeadd(identifier_list,
-						    result_string,
-						    strlen(result_string) +
-						    1)) {
+		if (!result_string || !(*(list **)identifier_list = list_nodeadd(*(list **)identifier_list, (char *)result_string, strlen(result_string) + 1))) {
 			db_free_result();
 			return -2;
 		}
diff -urNad dbmail-2.1/db.h /tmp/dpep.MIMNv7/dbmail-2.1/db.h
--- dbmail-2.1/db.h	2004-11-16 09:14:52.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/db.h	2004-11-16 09:29:02.000000000 +0100
@@ -314,14 +314,14 @@
 /**
  * \brief get a list of sieve scripts for a user
  * \param user_idnr user id
- * \param scriptlist pointer to struct list that will hold script names
+ * \param scriptlist pointer to list that will hold script names
  * \return
  *        - -2 on failure of allocating memory for string
  *        - -1 on database failure
  *        - 0 on success
- * \attention caller should free the struct list and its contents
+ * \attention caller should free the list and its contents
  */
-int db_get_sievescript_listall(u64_t user_idnr, struct list *scriptlist);
+int db_get_sievescript_listall(u64_t user_idnr, list *scriptlist);
 /**
  * \brief add/replace a sieve script for a user
  * \param user_idnr user id
@@ -615,7 +615,7 @@
 *      - 0 on success
 * \attention caller should free this memory
 */
-int db_icheck_messageblks(struct list *lost_list);
+int db_icheck_messageblks(list *lost_list);
 
 /**
  * \brief check for all messages that are not connected to
@@ -628,7 +628,7 @@
  *      - 0 on success
  * \attention caller should free this memory
  */
-int db_icheck_messages(struct list *lost_list);
+int db_icheck_messages(list *lost_list);
 
 /**
  * \brief check for all mailboxes that are not connected to
@@ -641,7 +641,7 @@
  *      - 0 on success
  * \attention caller should free this memory
  */
-int db_icheck_mailboxes(struct list *lost_list);
+int db_icheck_mailboxes(list *lost_list);
 
 /**
  * \brief check for all messages that are not connected to physmessage
@@ -656,7 +656,7 @@
  *      - 0 on success
  * \attention caller should free this memory
  */
-int db_icheck_null_messages(struct list *lost_list);
+int db_icheck_null_messages(list *lost_list);
 
 /**
  * \brief check for all physmessage records that have no messageblks 
@@ -670,7 +670,7 @@
  *     -  0 on success.
  * \attention caller should free this memory
  */
-int db_icheck_null_physmessages(struct list *lost_list);
+int db_icheck_null_physmessages(list *lost_list);
 
 /**
  * \brief set status of a message
@@ -1179,7 +1179,7 @@
  *    - 0 success
  * \attention hdrlist should be empty on call.
  */
-int db_get_main_header(u64_t msg_idnr, struct list *hdrlist);
+int db_get_main_header(u64_t msg_idnr, list *hdrlist);
 /**
  * \brief check if a message belongs to a mailbox
  * \param mailbox_idnr
@@ -1240,7 +1240,8 @@
  * \note identifier_list needs to be empty on call.
  */
 int db_acl_get_identifier(u64_t mboxid, 
-			  /*@out@*/ struct list *identifier_list);
+			  /*@out@*/ list *identifier_list);
+
 /**
  * constructs a string for use in queries. This is used to not be dependent
  * on the internal representation of a date in the database. Whenever the
@@ -1250,6 +1251,5 @@
  */
 char *date2char_str(const char *column);
 
-
 int db_getmailbox_list_result(u64_t mailbox_idnr, u64_t user_idnr, mailbox_t * mb);
 #endif
diff -urNad dbmail-2.1/dbmailtypes.h /tmp/dpep.MIMNv7/dbmail-2.1/dbmailtypes.h
--- dbmail-2.1/dbmailtypes.h	2004-11-04 12:03:02.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/dbmailtypes.h	2004-11-16 09:29:02.000000000 +0100
@@ -114,7 +114,7 @@
 			 /**< number of messages */
 	u64_t virtual_totalmessages;
 
-	struct list messagelst;
+	list *messagelst;
 			     /** list of messages */
 } PopSession_t;
 
@@ -190,7 +190,7 @@
 	u64_t size;
 	char search[MAX_SEARCH_LEN];
 	char hdrfld[MIME_FIELD_MAX];
-	struct list sub_search;
+	list sub_search;
 } search_key_t;
 
 /**
@@ -205,9 +205,9 @@
  * RFC822/MIME message data type
  */
 typedef struct {
-	struct list mimeheader;
+	list *mimeheader;
 			     /**< the MIME header of this part (if present) */
-	struct list rfcheader;
+	list *rfcheader;
 			     /**< RFC822 header of this part (if present) */
 	int message_has_errors;
 			     /**< if set the content-type is meaningless */
@@ -219,7 +219,7 @@
 		      /**< number of lines in message body */
 	u64_t rfcheadersize;
 			  /**< size of rfc header */
-	struct list children;
+	list *children;
 			    /**< the children (multipart msg) */
 	u64_t rfcheaderlines;
 			   /** number of lines in rfc header */
diff -urNad dbmail-2.1/dbsearch.c /tmp/dpep.MIMNv7/dbmail-2.1/dbsearch.c
--- dbmail-2.1/dbsearch.c	2004-10-25 21:28:19.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/dbsearch.c	2004-11-16 09:29:02.000000000 +0100
@@ -177,7 +177,7 @@
 
      unsigned int i;
      int result, idx = 0;
-     mime_message_t msg;
+     mime_message_t *msg = (mime_message_t *)my_malloc(sizeof(mime_message_t));
      struct mime_record *mr;
      sortitems_t *root = NULL;
 
@@ -190,23 +190,23 @@
      memset(rset, 0, sizeof(int)*setlen);
      /*create a btree for all messages hdrfld */
      for (i=0; i<setlen; i++) {
-          memset(&msg, 0, sizeof(msg));
+          memset(msg, 0, sizeof(msg));
 
-          result = db_fetch_headers(mb->seq_list[i], &msg);
+          result = db_fetch_headers(mb->seq_list[i], msg);
           if (result != 0)
                continue; /* ignore parse errors */
 
-          if (list_getstart(&msg.mimeheader)) {
-             mime_findfield(sk->hdrfld, &msg.mimeheader, &mr);
+          if (list_first(msg->mimeheader)) {
+             mime_findfield(sk->hdrfld, msg->mimeheader, &mr);
              if (mr)
               addto_btree_curr(&root, (char *)mr->value,(i+1));
           }
-          if (list_getstart(&msg.rfcheader)) {
-             mime_findfield(sk->hdrfld, &msg.rfcheader, &mr);
+          if (list_first(msg->rfcheader)) {
+             mime_findfield(sk->hdrfld, msg->rfcheader, &mr);
              if (mr)
               addto_btree_curr(&root, (char *)mr->value,(i+1));
           }
-          db_free_msg(&msg);
+          db_free_msg(msg);
     }
 
     list_btree_traverse(root, &idx, rset); /* fill in the rset array with mid's */
@@ -220,7 +220,7 @@
 {
 	unsigned i;
 	int result;
-	mime_message_t msg;
+	mime_message_t * msg = (mime_message_t *)my_malloc(sizeof(mime_message_t));
 
 	if (mb->exists != setlen)
 		return 1;
@@ -228,28 +228,28 @@
 	memset(rset, 0, sizeof(int) * setlen);
 
 	for (i = 0; i < setlen; i++) {
-		memset(&msg, 0, sizeof(msg));
+		memset(msg, 0, sizeof(msg));
 
-		result = db_fetch_headers(mb->seq_list[i], &msg);
+		result = db_fetch_headers(mb->seq_list[i], msg);
 		if (result != 0)
 			continue;	/* ignore parse errors */
 
 		if (sk->type == IST_SIZE_LARGER) {
 			rset[i] =
-			    ((msg.rfcheadersize + msg.bodylines +
-			      msg.bodysize) > sk->size)
+			    ((msg->rfcheadersize + msg->bodylines +
+			      msg->bodysize) > sk->size)
 			    ? 1 : 0;
 		} else if (sk->type == IST_SIZE_SMALLER) {
 			rset[i] =
-			    ((msg.rfcheadersize + msg.bodylines +
-			      msg.bodysize) < sk->size)
+			    ((msg->rfcheadersize + msg->bodylines +
+			      msg->bodysize) < sk->size)
 			    ? 1 : 0;
 		} else {
 			rset[i] =
-			    db_exec_search(&msg, sk, mb->seq_list[i]);
+			    db_exec_search(msg, sk, mb->seq_list[i]);
 		}
 
-		db_free_msg(&msg);
+		db_free_msg(msg);
 	}
 	return 0;
 }
@@ -276,7 +276,6 @@
 
 int db_exec_search(mime_message_t * msg, search_key_t * sk, u64_t msg_idnr)
 {
-	struct element *el;
 	struct mime_record *mr;
 	int i, givendate, sentdate;
 
@@ -285,23 +284,19 @@
 
 	switch (sk->type) {
 	case IST_HDR:
-		if (list_getstart(&msg->mimeheader)) {
-			mime_findfield(sk->hdrfld, &msg->mimeheader, &mr);
+		if (list_first(msg->mimeheader)) {
+			mime_findfield(sk->hdrfld, msg->mimeheader, &mr);
 			if (mr) {
 				for (i = 0; mr->value[i]; i++)
-					if (strncasecmp
-					    (&mr->value[i], sk->search,
-					     strlen(sk->search)) == 0)
+					if (strncasecmp (&mr->value[i], sk->search, strlen(sk->search)) == 0)
 						return 1;
 			}
 		}
-		if (list_getstart(&msg->rfcheader)) {
-			mime_findfield(sk->hdrfld, &msg->rfcheader, &mr);
+		if (list_first(msg->rfcheader)) {
+			mime_findfield(sk->hdrfld, msg->rfcheader, &mr);
 			if (mr) {
 				for (i = 0; mr->value[i]; i++)
-					if (strncasecmp
-					    (&mr->value[i], sk->search,
-					     strlen(sk->search)) == 0)
+					if (strncasecmp (&mr->value[i], sk->search, strlen(sk->search)) == 0)
 						return 1;
 			}
 		}
@@ -312,11 +307,9 @@
 	case IST_HDRDATE_ON:
 	case IST_HDRDATE_SINCE:
 		/* do not check children */
-		if (list_getstart(&msg->rfcheader)) {
-			mime_findfield("date", &msg->rfcheader, &mr);
-			if (mr
-			    && strlen(mr->value) >=
-			    strlen("Day, d mon yyyy "))
+		if (list_first(msg->rfcheader)) {
+			mime_findfield("date", msg->rfcheader, &mr);
+			if (mr && strlen(mr->value) >= strlen("Day, d mon yyyy "))
 				/* 01234567890123456 */
 			{
 				givendate = num_from_imapdate(sk->search);
@@ -326,8 +319,7 @@
 				else
 					mr->value[16] = 0;
 
-				sentdate =
-				    num_from_imapdate(&mr->value[5]);
+				sentdate = num_from_imapdate(&mr->value[5]);
 
 				switch (sk->type) {
 				case IST_HDRDATE_BEFORE:
@@ -342,72 +334,65 @@
 		return 0;
 
 	case IST_DATA_TEXT:
-		el = list_getstart(&msg->rfcheader);
-		while (el) {
-			mr = (struct mime_record *) el->data;
+		msg->rfcheader = list_first(msg->rfcheader);
+		while (msg->rfcheader) {
+			mr = msg->rfcheader->data;
 
 			for (i = 0; mr->field[i]; i++)
-				if (strncasecmp(&mr->field[i], sk->search,
-						strlen(sk->search)) == 0)
+				if (strncasecmp(&mr->field[i], sk->search, strlen(sk->search)) == 0)
 					return 1;
 
 			for (i = 0; mr->value[i]; i++)
-				if (strncasecmp(&mr->value[i], sk->search,
-						strlen(sk->search)) == 0)
+				if (strncasecmp(&mr->value[i], sk->search, strlen(sk->search)) == 0)
 					return 1;
 
-			el = el->nextnode;
+			msg->rfcheader = list_next(msg->rfcheader);
 		}
 
-		el = list_getstart(&msg->mimeheader);
-		while (el) {
-			mr = (struct mime_record *) el->data;
+		msg->mimeheader = list_first(msg->mimeheader);
+		while (msg->mimeheader) {
+			mr = msg->mimeheader->data;
 
 			for (i = 0; mr->field[i]; i++)
-				if (strncasecmp(&mr->field[i], sk->search,
-						strlen(sk->search)) == 0)
+				if (strncasecmp(&mr->field[i], sk->search, strlen(sk->search)) == 0)
 					return 1;
 
 			for (i = 0; mr->value[i]; i++)
-				if (strncasecmp(&mr->value[i], sk->search,
-						strlen(sk->search)) == 0)
+				if (strncasecmp(&mr->value[i], sk->search, strlen(sk->search)) == 0)
 					return 1;
 
-			el = el->nextnode;
+			msg->mimeheader = list_next(msg->mimeheader);
 		}
 		return 0;
 
 	case IST_DATA_BODY:
 		/* only check body if there are no children */
-		if (list_getstart(&msg->children))
+		if (list_first(msg->children))
 			break;
 
 		/* only check text bodies */
-		mime_findfield("content-type", &msg->mimeheader, &mr);
+		mime_findfield("content-type", msg->mimeheader, &mr);
 		if (mr && strncasecmp(mr->value, "text", 4) != 0)
 			break;
 
-		mime_findfield("content-type", &msg->rfcheader, &mr);
+		mime_findfield("content-type", msg->rfcheader, &mr);
 		if (mr && strncasecmp(mr->value, "text", 4) != 0)
 			break;
 
-		return db_search_range(msg->bodystart, msg->bodyend,
-				       sk->search, msg_idnr);
+		return db_search_range(msg->bodystart, msg->bodyend, sk->search, msg_idnr);
 	}
 	/* no match found yet, try the children */
-	el = list_getstart(&msg->children);
-	while (el) {
-		if (db_exec_search
-		    ((mime_message_t *) el->data, sk, msg_idnr) == 1)
+	msg->children = list_first(msg->children);
+	while (msg->children) {
+		if (db_exec_search ((mime_message_t *)msg->children->data, sk, msg_idnr) == 1)
 			return 1;
 
-		el = el->nextnode;
+		msg->children = list_next(msg->children);
 	}
 	return 0;
 }
 
-int db_search_range(db_pos_t start, db_pos_t end,
-		    const char *key, u64_t msg_idnr)
+int db_search_range(db_pos_t start, db_pos_t end, const char *key, u64_t msg_idnr)
 {
 	unsigned i, j;
 	unsigned startpos, endpos;
@@ -416,14 +401,12 @@
 	const char *query_result;
 
 	if (start.block > end.block) {
-		trace(TRACE_ERROR, "%s,%s: bad range specified",
-		      __FILE__, __func__);
+		trace(TRACE_ERROR, "%s,%s: bad range specified", __FILE__, __func__);
 		return 0;
 	}
 
 	if (start.block == end.block && start.pos > end.pos) {
-		trace(TRACE_ERROR, "%s,%s: bad range specified",
-		      __FILE__, __func__);
+		trace(TRACE_ERROR, "%s,%s: bad range specified", __FILE__, __func__);
 		return 0;
 	}
 
@@ -460,8 +443,7 @@
 	/* just one block? */
 	if (start.block == end.block) {
 		for (i = start.pos; i <= end.pos - strlen(key); i++) {
-			if (strncasecmp(&query_result[i], key, strlen(key))
-			    == 0) {
+			if (strncasecmp(&query_result[i], key, strlen(key)) == 0) {
 				db_free_result();
 				return 1;
 			}
@@ -478,21 +460,18 @@
 
 	for (i = start.block; i <= end.block; i++) {
 		if (!query_result) {
-			trace(TRACE_ERROR, "%s,%s: bad range specified",
-			      __FILE__, __func__);
+			trace(TRACE_ERROR, "%s,%s: bad range specified", __FILE__, __func__);
 			db_free_result();
 			return 0;
 		}
 
 		startpos = (i == start.block) ? start.pos : 0;
-		endpos =
-		    (i == end.block) ? end.pos + 1 : db_get_length(i, 0);
+		endpos = (i == end.block) ? end.pos + 1 : db_get_length(i, 0);
 
 		distance = endpos - startpos;
 
 		for (j = 0; j < distance - strlen(key); j++) {
-			if (strncasecmp(&query_result[i], key, strlen(key))
-			    == 0) {
+			if (strncasecmp(&query_result[i], key, strlen(key)) == 0) {
 				db_free_result();
 				return 1;
 			}
diff -urNad dbmail-2.1/dsn.c /tmp/dpep.MIMNv7/dbmail-2.1/dsn.c
--- dbmail-2.1/dsn.c	2004-08-29 11:10:06.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/dsn.c	2004-11-16 09:29:02.000000000 +0100
@@ -204,10 +204,10 @@
 	dsnuser->address = NULL;
 	dsnuser->mailbox = NULL;
 
-	dsnuser->userids = (struct list *) my_malloc(sizeof(struct list));
+	dsnuser->userids = (list *) my_malloc(sizeof(list));
 	if (dsnuser->userids == NULL)
 		return -1;
-	dsnuser->forwards = (struct list *) my_malloc(sizeof(struct list));
+	dsnuser->forwards = (list *) my_malloc(sizeof(list));
 	if (dsnuser->forwards == NULL) {
 		my_free(dsnuser->userids);
 		return -1;
@@ -234,28 +234,24 @@
 	my_free((char *) dsnuser->address);
 	my_free((char *) dsnuser->mailbox);
 
-	list_freelist(&dsnuser->userids->start);
-	list_freelist(&dsnuser->forwards->start);
-
-	my_free(dsnuser->userids);
-	my_free(dsnuser->forwards);
+	list_freelist(dsnuser->userids);
+	list_freelist(dsnuser->forwards);
 
 	trace(TRACE_DEBUG, "%s, %s: dsnuser freed",
 	      __FILE__, __func__);
 }
 
 
-int dsnuser_resolve_list(struct list *deliveries)
+int dsnuser_resolve_list(list *deliveries)
 {
 	int ret;
-	struct element *element;
-
 	/* Loop through the users list */
-	for (element = list_getstart(deliveries); element != NULL;
-	     element = element->nextnode) {
-		if ((ret = dsnuser_resolve((deliver_to_user_t *) element->data)) != 0) {
+	deliveries = list_first(deliveries);
+	while(deliveries) {
+		if ((ret = dsnuser_resolve((deliver_to_user_t *) deliveries->data)) != 0) {
 			return ret;
 		}
+		deliveries = list_next(deliveries);
 	}
 
 	return 0;
@@ -277,12 +273,8 @@
 			my_free(username);
 
 			/* Copy the delivery useridnr into the userids list. */
-			if (list_nodeadd(delivery->userids,
-			     &delivery->useridnr,
-			     sizeof(delivery->useridnr)) == 0) {
-				trace(TRACE_ERROR,
-				      "%s, %s: out of memory",
-				      __FILE__, __func__);
+			if (! (delivery->userids = list_nodeadd(delivery->userids, &delivery->useridnr, sizeof(delivery->useridnr)))) {
+				trace(TRACE_ERROR, "%s, %s: out of memory", __FILE__, __func__);
 				return -1;
 			}
 
@@ -313,10 +305,8 @@
 			}
 		case 1:
 			{
-				if (list_nodeadd(delivery->userids, &userid,
-				     sizeof(u64_t)) == 0) {
-					trace(TRACE_ERROR, "%s, %s: out of memory",
-					      __FILE__, __func__);
+				if (!(delivery->userids = list_nodeadd(delivery->userids, &userid, sizeof(u64_t)))) {
+					trace(TRACE_ERROR, "%s, %s: out of memory", __FILE__, __func__);
 					return -1;
 				} else {
 
@@ -396,15 +386,14 @@
 	return 0;
 }
 
-void dsnuser_free_list(struct list *deliveries)
+void dsnuser_free_list(list *deliveries)
 {
-	struct element *tmp;
-
-	for (tmp = list_getstart(deliveries); tmp != NULL;
-	     tmp = tmp->nextnode)
-		dsnuser_free((deliver_to_user_t *) tmp->data);
-
-	list_freelist(&deliveries->start);
+	deliveries = list_first(deliveries);
+	while(deliveries) {
+		dsnuser_free((deliver_to_user_t *) deliveries->data);
+		deliveries = list_next(deliveries);
+	}
+	list_freelist(deliveries);
 }
 
 dsn_class_t dsnuser_worstcase_int(int has_2, int has_4, int has_5)
@@ -432,15 +421,15 @@
 	return exitcode;
 }
 
-dsn_class_t dsnuser_worstcase_list(struct list * deliveries)
+dsn_class_t dsnuser_worstcase_list(list * deliveries)
 {
 	struct element *tmp;
 	int has_2 = 0, has_4 = 0, has_5 = 0;
 
 	/* Get one reasonable error code for everyone. */
-	for (tmp = list_getstart(deliveries); tmp != NULL;
-	     tmp = tmp->nextnode) {
-		switch (((deliver_to_user_t *) tmp->data)->dsn.class) {
+	deliveries = list_first(deliveries);
+	while(deliveries) {
+		switch (((deliver_to_user_t *) deliveries->data)->dsn.class) {
 		case DSN_CLASS_OK:
 			/* Success. */
 			has_2 = 1;
@@ -454,6 +443,7 @@
 			has_5 = 1;
 			break;
 		}
+		deliveries = list_next(deliveries);
 	}
 
 	/* If we never made it into the list, all zeroes will
diff -urNad dbmail-2.1/dsn.h /tmp/dpep.MIMNv7/dbmail-2.1/dsn.h
--- dbmail-2.1/dsn.h	2004-08-29 11:10:06.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/dsn.h	2004-11-16 09:29:02.000000000 +0100
@@ -38,8 +38,8 @@
 	u64_t useridnr;		/* Specific user id recipient (from outside). */
 	const char *address;	/* Envelope recipient (from outside). */
 	const char *mailbox;	/* Default mailbox to use for userid deliveries (from outside). */
-	struct list *userids;	/* List of u64_t* -- internal useridnr's to deliver to (internal). */
-	struct list *forwards;	/* List of char* -- external addresses to forward to (internal). */
+	list *userids;	/* List of u64_t* -- internal useridnr's to deliver to (internal). */
+	list *forwards;	/* List of char* -- external addresses to forward to (internal). */
 	delivery_status_t dsn;	/* Return status of this "delivery basket" (to outside). */
 } deliver_to_user_t;
 
@@ -67,7 +67,7 @@
 int dsnuser_init(deliver_to_user_t * dsnuser);
 
 void dsnuser_free(deliver_to_user_t * dsnuser);
-void dsnuser_free_list(struct list *deliveries);
+void dsnuser_free_list(list *deliveries);
 
 /**
  * \brief Loop through the list of delivery addresses
@@ -81,7 +81,7 @@
  *   - 0 on success
  *   - -1 on failure
  */
-int dsnuser_resolve_list(struct list *deliveries);
+int dsnuser_resolve_list(list *deliveries);
 
 /**
  * \brief The dsnuser structure should have either a useridnr or
@@ -105,7 +105,7 @@
  * \return
  *   - see dsn_class_t for details.
  */
-dsn_class_t dsnuser_worstcase_list(struct list *deliveries);
+dsn_class_t dsnuser_worstcase_list(list *deliveries);
 
 /**
  * \brief Given true/false values for each of the three
diff -urNad dbmail-2.1/forward.c /tmp/dpep.MIMNv7/dbmail-2.1/forward.c
--- dbmail-2.1/forward.c	2004-06-30 10:55:55.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/forward.c	2004-11-16 09:29:02.000000000 +0100
@@ -43,7 +43,7 @@
  * FIXME: there is no detail in the error reporting,
  * so there's no way to tell *which* targets failed...
  * */
-int forward(u64_t msgidnr, struct list *targets, const char *from,
+int forward(u64_t msgidnr, list *targets, const char *from,
 	    const char *header, u64_t headersize UNUSED)
 {
 	struct element *target = NULL;
@@ -77,28 +77,26 @@
 		return -1;
 	}
 
-	target = list_getstart(targets);
+	targets = list_first(targets);
 
-	while (target != NULL) {
-		if ((((char *) target->data)[0] == '|')
-		    || (((char *) target->data)[0] == '!')) {
+	while (targets) {
+		target = targets->data;
+		if ((((char *) target)[0] == '|') || (((char *) target)[0] == '!')) {
 
 			/* external pipe command */
-			command_len = strlen((char *) (target->data)) + 1;
+			command_len = strlen((char *) (target)) + 1;
 			command = my_malloc(command_len * sizeof(char));
 			if (!command) {
-				trace(TRACE_ERROR,
-				      "%s,%s: out of memory",
-				      __FILE__, __func__);
+				trace(TRACE_ERROR, "%s,%s: out of memory", __FILE__, __func__);
 				return -1;
 			}
 			/* skip the pipe (|) sign */
-			strncpy(command, (char *) (target->data) + 1, command_len);
+			strncpy(command, (char *) (target) + 1, command_len);
 		} else {
 			/* pipe to sendmail */
 			command_len = strlen(sendmail) + strlen(" -f ") +
 				strlen(from) + strlen (" ") +
-				strlen((char *) (target->data)) + 1;
+				strlen((char *) (target)) + 1;
 			command = my_malloc(command_len * sizeof(char));
 			if (!command) {
 				trace(TRACE_ERROR,
@@ -111,7 +109,7 @@
 			      "%s,%s: allocated memory for external "
 			      "command call", __FILE__, __func__);
 			snprintf(command, command_len, "%s -f %s %s", sendmail, from, 
-				(char *) (target->data));
+				(char *) (target));
 		}
 
 		trace(TRACE_INFO, "%s,%s: opening pipe to command %s",
@@ -127,15 +125,14 @@
 			      "opened pipe [%d]", __FILE__, __func__,
 			      fileno(pipe));
 
-			if (((char *) target->data)[0] == '!') {
+			if (((char *) target)[0] == '!') {
 				/* ! tells us to prepend an mbox style header in this pipe */
 				trace(TRACE_DEBUG,
 				      "%s,%s: appending mbox style from "
 				      "header to pipe returnpath : %s",
 				      __FILE__, __func__, from);
 				/* format: From<space>address<space><space>Date */
-				fprintf(pipe, "From %s  %s\n", from,
-					timestr);
+				fprintf(pipe, "From %s  %s\n", from, timestr);
 			}
 
 			trace(TRACE_INFO,
@@ -189,7 +186,7 @@
 			      "%s,%s: Could not open pipe to [%s]",
 			      __FILE__, __func__, sendmail);
 		}
-		target = target->nextnode;
+		targets = list_next(targets);
 	}
 	return 0;
 }
diff -urNad dbmail-2.1/forward.h /tmp/dpep.MIMNv7/dbmail-2.1/forward.h
--- dbmail-2.1/forward.h	2004-03-19 17:27:38.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/forward.h	2004-11-16 09:29:02.000000000 +0100
@@ -29,7 +29,7 @@
 
 #define FW_SENDMAIL SENDMAIL
 
-int forward(u64_t msgidnr, struct list *targets, const char *from,
+int forward(u64_t msgidnr, list *targets, const char *from,
 	    const char *header, u64_t headersize);
 
 #endif
diff -urNad dbmail-2.1/imap4.c /tmp/dpep.MIMNv7/dbmail-2.1/imap4.c
--- dbmail-2.1/imap4.c	2004-11-16 09:26:54.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/imap4.c	2004-11-16 09:29:02.000000000 +0100
@@ -17,7 +17,7 @@
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-/* $Id$
+/* $Id$
  * imap4.c
  *
  * implements an IMAP 4 rev 1 server.
@@ -302,7 +302,6 @@
 				/* some error occurred during the read of extra command info */
 				trace(TRACE_ERROR, "IMAPClientHandler(): error reading extra command info");
 				ci_cleanup(session->ci);
-				dbmail_imap_session_delete(session);
 				return -1;
 			}
 		}
@@ -310,7 +309,6 @@
 		if (!args) {
 			if (ci_write(session->ci->tx, "%s BAD invalid argument specified\r\n",session->tag)) {
 				ci_cleanup(session->ci);
-				dbmail_imap_session_delete(session);
 				return EOF;
 			}
 				
@@ -325,10 +323,16 @@
 			/* unknown command */
 			if (ci_write(session->ci->tx, "%s BAD command not recognized\r\n",session->tag)) {
 				ci_cleanup(session->ci);
-				dbmail_imap_session_delete(session);
 				return EOF;
 			}
 			nfaultyresponses++;
+
+			/* free used memory */
+			for (i = 0; session->args[i]; i++) {
+				my_free(session->args[i]);
+				session->args[i] = NULL;
+			}
+
 			continue;
 		}
 
@@ -378,17 +382,22 @@
 
 				result = db_getmailbox(&newmailbox);
 				if (result == -1) {
+					if (ci_write(session->ci->tx, "* BYE internal dbase error\r\n")) {
+						ci_cleanup(session->ci);
+						return EOF;
+					}
 					trace(TRACE_ERROR, "IMAPClientHandler(): could not get mailbox info\n");
-					ci_write(session->ci->tx, "* BYE internal dbase error\r\n");
 					ci_cleanup(session->ci);
-					dbmail_imap_session_delete(session);
+					for (i = 0; session->args[i]; i++) {
+						my_free(session->args[i]);
+						session->args[i] = NULL;
+					}
 					return -1;
 				}
 
 				if (newmailbox.exists != ud->mailbox.exists) {
 					if(ci_write(session->ci->tx, "* %u EXISTS\r\n", newmailbox.exists)) {
 						ci_cleanup(session->ci);
-						dbmail_imap_session_delete(session);
 						return EOF;
 					}
 					trace(TRACE_INFO, "IMAPClientHandler(): ok update sent\r\n");
@@ -397,7 +406,6 @@
 				if (newmailbox.recent != ud->mailbox.recent)
 					if(ci_write(session->ci->tx, "* %u RECENT\r\n", newmailbox.recent)) {
 						ci_cleanup(session->ci);
-						dbmail_imap_session_delete(session);
 						return EOF;
 					}
 
@@ -408,18 +416,23 @@
 		if (this_was_noop) {
 			if(ci_write(session->ci->tx, "%s OK NOOP completed\r\n", session->tag)) {
 				ci_cleanup(session->ci);
-				dbmail_imap_session_delete(session);
 				return EOF; 
 			}
 			trace(TRACE_DEBUG, "%s,%s: tag = %s", __FILE__, __func__, session->tag);
 		}
+		for (i = 0; session->args[i]; i++) {
+			my_free(session->args[i]);
+			session->args[i] = NULL;
+		}
 
 	} while (!done);
 
 	/* cleanup */
-	ci_write(session->ci->tx, "%s OK completed\r\n", session->tag);
+	if (ci_write(session->ci->tx, "%s OK completed\r\n", session->tag)) {
+		ci_cleanup(session->ci);
+		return EOF;
+	}
 	ci_cleanup(session->ci);
-	dbmail_imap_session_delete(session);
 	trace(TRACE_MESSAGE, "IMAPClientHandler(): Closing connection for client from IP [%s]\n", session->ci->ip);
 
 	__debug_dumpallocs();
diff -urNad dbmail-2.1/imapcommands.c /tmp/dpep.MIMNv7/dbmail-2.1/imapcommands.c
--- dbmail-2.1/imapcommands.c	2004-11-15 16:57:07.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/imapcommands.c	2004-11-16 09:29:02.000000000 +0100
@@ -2240,7 +2240,6 @@
 				dbmail_imap_session_printf(self, "%s OK FETCH completed\r\n", self->tag);
 			else
 				dbmail_imap_session_printf(self, "%s BAD invalid message range specified\r\n", self->tag);
-
 			return !self->fi.getUID;
 		}
 
diff -urNad dbmail-2.1/imaputil.c /tmp/dpep.MIMNv7/dbmail-2.1/imaputil.c
--- dbmail-2.1/imaputil.c	2004-11-16 09:03:38.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/imaputil.c	2004-11-16 09:29:02.000000000 +0100
@@ -196,22 +196,22 @@
 		       int show_extension_data)
 {
 	struct mime_record *mr;
-	struct element *curr;
-	struct list *header_to_use;
-	mime_message_t rfcmsg;
+	list *children;
+	list *header_to_use;
+	mime_message_t *rfcmsg = NULL;
 	char *subtype, *extension, *newline;
 	int is_mime_multipart = 0, is_rfc_multipart = 0;
 	int rfc822 = 0;
 
 	fprintf(outstream, "(");
 
-	mime_findfield("content-type", &msg->mimeheader, &mr);
+	mime_findfield("content-type", msg->mimeheader, &mr);
 	is_mime_multipart = (mr
 			     && strncasecmp(mr->value, "multipart",
 					    strlen("multipart")) == 0
 			     && !msg->message_has_errors);
 
-	mime_findfield("content-type", &msg->rfcheader, &mr);
+	mime_findfield("content-type", msg->rfcheader, &mr);
 	is_rfc_multipart = (mr
 			    && strncasecmp(mr->value, "multipart",
 					   strlen("multipart")) == 0
@@ -232,10 +232,10 @@
 		 * size
 		 */
 
-		if (msg->mimeheader.start == NULL)
-			header_to_use = &msg->rfcheader;	/* we're dealing with a single-part RFC msg here */
+		if (msg->mimeheader== NULL)
+			header_to_use = msg->rfcheader;	/* we're dealing with a single-part RFC msg here */
 		else
-			header_to_use = &msg->mimeheader;	/* we're dealing with a pure-MIME header here */
+			header_to_use = msg->mimeheader;	/* we're dealing with a pure-MIME header here */
 
 		mime_findfield("content-type", header_to_use, &mr);
 		if (mr && strlen(mr->value) > 0)
@@ -267,7 +267,7 @@
 
 		/* now output size */
 		/* add msg->bodylines because \n is dumped as \r\n */
-		if (msg->mimeheader.start && msg->rfcheader.start)
+		if (msg->mimeheader && msg->rfcheader)
 			fprintf(outstream, " %llu",
 				msg->bodysize + msg->mimerfclines +
 				msg->rfcheadersize - msg->rfcheaderlines);
@@ -281,24 +281,24 @@
 		if (mr
 		    && strncasecmp(mr->value, "message/rfc822",
 				   strlen("message/rfc822")) == 0
-		    && header_to_use != &msg->rfcheader) {
+		    && header_to_use != msg->rfcheader) {
 			/* msg/rfc822 found; extra items to be displayed:
 			 * (a) body envelope of rfc822 msg
 			 * (b) body structure of rfc822 msg
 			 * (c) msg size (lines)
 			 */
 
-			if (retrieve_envelope(outstream, &msg->rfcheader)
+			if (retrieve_envelope(outstream, msg->rfcheader)
 			    == -1)
 				return -1;
 
 			fprintf(outstream, " ");
 
-			memmove(&rfcmsg, msg, sizeof(rfcmsg));
-			rfcmsg.mimeheader.start = NULL;	/* forget MIME-part */
+			memmove(rfcmsg, msg, sizeof(rfcmsg));
+			rfcmsg->mimeheader = NULL;	/* forget MIME-part */
 			
 			if (retrieve_structure
-			    (outstream, &rfcmsg,
+			    (outstream, rfcmsg,
 			     show_extension_data) == -1)
 				return -1;
 
@@ -312,7 +312,7 @@
 		     && strncasecmp(mr->value, "text",
 				    strlen("text")) == 0) || !mr) {
 			/* output # of lines */
-			if (msg->mimeheader.start && msg->rfcheader.start)
+			if (msg->mimeheader && msg->rfcheader)
 				fprintf(outstream, " %llu",
 					msg->mimerfclines);
 			else
@@ -348,24 +348,24 @@
 	} else {
 		/* check for a multipart message */
 		if (is_rfc_multipart || is_mime_multipart) {
-			curr = list_getstart(&msg->children);
-			while (curr) {
+			children = list_first(msg->children);
+			while (children) {
 				if (retrieve_structure
 				    (outstream,
-				     (mime_message_t *) curr->data,
+				     (mime_message_t *) children->data,
 				     show_extension_data) == -1)
 					return -1;
 
-				curr = curr->nextnode;
+				children = list_next(children);
 			}
 
 			/* show multipart subtype */
 			if (is_mime_multipart)
 				mime_findfield("content-type",
-					       &msg->mimeheader, &mr);
+					       msg->mimeheader, &mr);
 			else
 				mime_findfield("content-type",
-					       &msg->rfcheader, &mr);
+					       msg->rfcheader, &mr);
 
 			subtype = strchr(mr->value, '/');
 			extension = strchr(subtype, ';');
@@ -417,7 +417,7 @@
  *
  * returns -1 on error, 0 on success
  */
-int retrieve_envelope(FILE * outstream, struct list *rfcheader)
+int retrieve_envelope(FILE * outstream, list *rfcheader)
 {
 	struct mime_record *mr;
 	int idx;
@@ -763,23 +763,23 @@
 {
 	int nextpart, j;
 	char *endptr;
-	struct element *curr;
+	list *children;
 
 	if (part == NULL || strlen(part) == 0 || msg == NULL)
 		return msg;
 
 	nextpart = strtoul(part, &endptr, 10);	/* strtoul() stops at '.' */
 
-	for (j = 1, curr = list_getstart(&msg->children);
-	     j < nextpart && curr; j++, curr = curr->nextnode);
+	children = list_first(msg->children);
+	for (j = 1; j < nextpart && children; j++, children = list_next(children));
 
-	if (!curr)
+	if (!children)
 		return NULL;
 
 	if (*endptr)
-		return get_part_by_num((mime_message_t *) curr->data, &endptr[1]);	/* skip dot in part */
+		return get_part_by_num((mime_message_t *) children->data, &endptr[1]);	/* skip dot in part */
 
-	return (mime_message_t *) curr->data;
+	return (mime_message_t *) children->data;
 }
 
 
@@ -796,22 +796,20 @@
  *
  * returns number of bytes written to outmem
  */
-u64_t rfcheader_dump(MEM * outmem, struct list * rfcheader,
+u64_t rfcheader_dump(MEM * outmem, list * rfcheader,
 		     char **fieldnames, int nfields, int equal_type)
 {
 	struct mime_record *mr;
-	struct element *curr;
 	u64_t size = 0;
 
-	curr = list_getstart(rfcheader);
-	if (rfcheader == NULL || curr == NULL) {
+	rfcheader = list_first(rfcheader);
+	if (rfcheader == NULL) {
 		/*size += fprintf(outstream, "NIL\r\n"); */
 		return 0;
 	}
 
-	curr = list_getstart(rfcheader);
-	while (curr) {
-		mr = (struct mime_record *) curr->data;
+	while (rfcheader) {
+		mr = (struct mime_record *) rfcheader->data;
 
 		if (haystack_find(nfields, fieldnames, mr->field) ==
 		    equal_type) {
@@ -824,7 +822,7 @@
 			size += mwrite("\r\n", 2, outmem);
 		}
 
-		curr = curr->nextnode;
+		rfcheader = list_next(rfcheader);
 	}
 	size += mwrite("\r\n", 2, outmem);
 
@@ -838,25 +836,24 @@
  * dumps mime-header fields belonging to mimeheader
  *
  */
-u64_t mimeheader_dump(MEM * outmem, struct list * mimeheader)
+u64_t mimeheader_dump(MEM * outmem, list * mimeheader)
 {
 	struct mime_record *mr;
-	struct element *curr;
 	u64_t size = 0;
 
-	curr = list_getstart(mimeheader);
-	if (mimeheader == NULL || curr == NULL) {
+	mimeheader = list_first(mimeheader);
+	if (mimeheader == NULL) {
 		/*size = fprintf(outstream, "NIL\r\n"); */
 		return 0;
 	}
 
-	while (curr) {
-		mr = (struct mime_record *) curr->data;
+	while (mimeheader) {
+		mr = (struct mime_record *) mimeheader->data;
 		size += mwrite(mr->field, strlen(mr->field), outmem);
 		size += mwrite(": ", 2, outmem);
 		size += mwrite(mr->value, strlen(mr->value), outmem);
 		size += mwrite("\r\n", 2, outmem);
-		curr = curr->nextnode;
+		mimeheader = list_next(mimeheader);
 	}
 	size += mwrite("\r\n", 2, outmem);
 
@@ -1835,7 +1832,7 @@
  *
  * checks if content-type is text/plain
  */
-int is_textplain(struct list *hdr)
+int is_textplain(list *hdr)
 {
 	struct mime_record *mr;
 	int i, len;
@@ -2269,7 +2266,7 @@
  *
  * returns -1 on syntax error, -2 on memory error; 0 on success, 1 if ')' has been encountered
  */
-int build_imap_search(char **search_keys, struct list *sl, int *idx, int sorted)
+int build_imap_search(char **search_keys, list *sl, int *idx, int sorted)
 {
 	search_key_t key;
 	int result;
@@ -2606,12 +2603,12 @@
 		if ((result =
 		     build_imap_search(search_keys, &key.sub_search,
 				       idx, sorted )) < 0) {
-			list_freelist(&key.sub_search.start);
+			list_freelist(&key.sub_search);
 			return result;
 		}
 
 		/* a NOT should be unary */
-		if (key.sub_search.total_nodes != 1) {
+		if (list_totalnodes(&key.sub_search) != 1) {
 			free_searchlist(&key.sub_search);
 			return -1;
 		}
@@ -2622,19 +2619,19 @@
 		if ((result =
 		     build_imap_search(search_keys, &key.sub_search,
 				       idx, sorted)) < 0) {
-			list_freelist(&key.sub_search.start);
+			list_freelist(&key.sub_search);
 			return result;
 		}
 
 		if ((result =
 		     build_imap_search(search_keys, &key.sub_search,
 				       idx, sorted )) < 0) {
-			list_freelist(&key.sub_search.start);
+			list_freelist(&key.sub_search);
 			return result;
 		}
 
 		/* an OR should be binary */
-		if (key.sub_search.total_nodes != 2) {
+		if (list_totalnodes(&key.sub_search) != 2) {
 			free_searchlist(&key.sub_search);
 			return -1;
 		}
@@ -2649,7 +2646,7 @@
 
 		if (result < 0) {
 			/* error */
-			list_freelist(&key.sub_search.start);
+			list_freelist(&key.sub_search);
 			return result;
 		}
 
@@ -2670,7 +2667,7 @@
 		return -1;
 	}
 
-	if (!list_nodeadd(sl, &key, sizeof(key)))
+	if (! (*(list **)sl = list_nodeadd(*(list **)sl, &key, sizeof(key))))
 		return -2;
 
 	return 0;
@@ -2687,10 +2684,10 @@
 			mailbox_t * mb, int sorted)
 {
 	search_key_t *subsk;
-	struct element *el;
 	int result, *newset = NULL, i;
 	int subtype = IST_SUBSEARCH_OR;
-
+	list *subsearch = &sk->sub_search;
+	
 	if (!rset)
 		return -2;	/* stupidity */
 
@@ -2758,9 +2755,9 @@
 		subtype = IST_SUBSEARCH_AND;
 
 	case IST_SUBSEARCH_OR:
-		el = list_getstart(&sk->sub_search);
-		while (el) {
-			subsk = (search_key_t *) el->data;
+		subsearch = list_first(&sk->sub_search);
+		while (subsearch) {
+			subsk = (search_key_t *) subsearch->data;
 
 			if (subsk->type == IST_SUBSEARCH_OR)
 				memset(newset, 0, sizeof(int) * setlen);
@@ -2782,7 +2779,7 @@
 					rset[i] = newset[i];
 			}
  
-			el = el->nextnode;
+			subsearch = list_next(subsearch);
 		}
 
 		if (sk->type == IST_SUBSEARCH_NOT)
@@ -2804,26 +2801,25 @@
  * frees the search-list sl
  *
  */
-void free_searchlist(struct list *sl)
+void free_searchlist(list *sl)
 {
 	search_key_t *sk;
-	struct element *el;
 
 	if (!sl)
 		return;
 
-	el = list_getstart(sl);
+	sl = list_first(sl);
 
-	while (el) {
-		sk = (search_key_t *) el->data;
+	while (sl) {
+		sk = (search_key_t *) sl->data;
 
 		free_searchlist(&sk->sub_search);
-		list_freelist(&sk->sub_search.start);
+		list_freelist(&sk->sub_search);
 
-		el = el->nextnode;
+		sl = list_next(sl);
 	}
 
-	list_freelist(&sl->start);
+	list_freelist(sl);
 	return;
 }
 
@@ -3061,8 +3057,8 @@
 void dumpsearch(search_key_t * sk, int level)
 {
 	char *spaces = (char *) my_malloc(level * 3 + 1);
-	struct element *el;
 	search_key_t *subsk;
+	list *subsearch = &sk->sub_search;
 
 	if (!spaces)
 		return;
@@ -3080,9 +3076,9 @@
 	case IST_SUBSEARCH_NOT:
 		trace(TRACE_DEBUG, "%sNOT\n", spaces);
 
-		el = list_getstart(&sk->sub_search);
-		if (el)
-			subsk = (search_key_t *) el->data;
+		subsearch = list_first(subsearch);
+		if (subsearch)
+			subsk = (search_key_t *) subsearch->data;
 		else
 			subsk = NULL;
 
@@ -3091,25 +3087,25 @@
 
 	case IST_SUBSEARCH_AND:
 		trace(TRACE_DEBUG, "%sAND\n", spaces);
-		el = list_getstart(&sk->sub_search);
 
-		while (el) {
-			subsk = (search_key_t *) el->data;
+		subsearch = list_first(subsearch);
+		while (subsearch) {
+			subsk = (search_key_t *) subsearch->data;
 			dumpsearch(subsk, level + 1);
 
-			el = el->nextnode;
+			subsearch = list_next(subsearch);
 		}
 		break;
 
 	case IST_SUBSEARCH_OR:
 		trace(TRACE_DEBUG, "%sOR\n", spaces);
-		el = list_getstart(&sk->sub_search);
 
-		while (el) {
-			subsk = (search_key_t *) el->data;
+		subsearch = list_first(subsearch);
+		while (subsearch) {
+			subsk = (search_key_t *)subsearch->data;
 			dumpsearch(subsk, level + 1);
 
-			el = el->nextnode;
+			subsearch = list_next(subsearch);
 		}
 		break;
 
diff -urNad dbmail-2.1/imaputil.h /tmp/dpep.MIMNv7/dbmail-2.1/imaputil.h
--- dbmail-2.1/imaputil.h	2004-10-21 11:57:23.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/imaputil.h	2004-11-16 09:29:02.000000000 +0100
@@ -41,21 +41,21 @@
 
 int retrieve_structure(FILE * outstream, mime_message_t * msg,
 		       int show_extension_data);
-int retrieve_envelope(FILE * outstream, struct list *rfcheader);
+int retrieve_envelope(FILE * outstream, list *rfcheader);
 int show_address_list(FILE * outstream, struct mime_record *mr);
 int show_mime_parameter_list(FILE * outstream, struct mime_record *mr,
 			     int force_subtype, int only_extension);
 
 mime_message_t *get_part_by_num(mime_message_t * msg, const char *part);
 
-u64_t rfcheader_dump(MEM * outmem, struct list *rfcheader,
+u64_t rfcheader_dump(MEM * outmem, list *rfcheader,
 		     char **fieldnames, int nfields, int equal_type);
-u64_t mimeheader_dump(MEM * outmem, struct list *mimeheader);
+u64_t mimeheader_dump(MEM * outmem, list *mimeheader);
 
 int haystack_find(int haystacklen, char **haystack, const char *needle);
 
 int next_fetch_item(char **args, int idx, fetch_items_t * fi);
-int is_textplain(struct list *hdr);
+int is_textplain(list *hdr);
 
 char *date_sql2imap(const char *sqldate);
 char *date_imap2sql(const char *imapdate);
@@ -80,10 +80,10 @@
 int quoted_string_out(FILE * outstream, const char *s);
 void send_data(FILE * to, MEM * from, int cnt);
 
-int build_imap_search(char **search_keys, struct list *sl, int *idx, int sorted);
+int build_imap_search(char **search_keys, list *sl, int *idx, int sorted);
 int perform_imap_search(int *rset, int setlen, search_key_t * sk,
 			mailbox_t * mb, int sorted);
-void free_searchlist(struct list *sl);
+void free_searchlist(list *sl);
 
 void invert_set(int *set, int setlen);
 void combine_sets(int *dest, int *sec, int setlen, int type);
diff -urNad dbmail-2.1/list.c /tmp/dpep.MIMNv7/dbmail-2.1/list.c
--- dbmail-2.1/list.c	2004-09-14 11:15:04.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/list.c	2004-11-16 09:29:02.000000000 +0100
@@ -31,31 +31,40 @@
 #include "debug.h"
 #include "list.h"
 
-void list_init(struct list *tlist)
+/*done*/
+void list_init(list *tlist)
 {
-	tlist->start = NULL;
-	tlist->total_nodes = 0;
+	/* glib takes care of this... etc */
+	if(tlist != NULL){
+		tlist->data = NULL;
+		tlist->prev = NULL;
+		tlist->next = NULL;
+	}
 }
 
 
+/*done*/
 /*
  * list_freelist()
  *
  * frees a list and all the memory associated with it
  */
-void list_freelist(struct element **start)
+void _list_freeeach (gpointer item, gpointer temp UNUSED)
 {
-	/* check if list exists */
-	if (!(*start))
-		return;
-
-	/* free rest of list */
-	list_freelist(&(*start)->nextnode);
+ /* for now this is a debuging function only dmalloc will crash if you free other memory .e.g glist memory */
+	if(item != NULL){
+	 //trace(TRACE_DEBUG, "%lu free_foreach addr %p", get_mythreadid(), item);
+	 //my_free(item);
+  }
+}
 
-	/* free this item */
-	my_free((*start)->data);
-	my_free(*start);
-	*start = NULL;
+/*done*/
+void list_freelist(list *tlist)
+{
+	//trace(TRACE_DEBUG, "%lu calling list_freelist with total nodes %ld", get_mythreadid(), list_totalnodes(tlist));
+	//list_foreach(tlist, (GFunc)_list_freeeach, NULL);
+	g_list_free(tlist);
+	tlist = NULL;
 }
 
 /* 
@@ -63,22 +72,9 @@
  *
  * reverse the order of a linked list
  */
-struct element *dbmail_list_reverse(struct element *start)
+list *dbmail_list_reverse(list * tlist)
 {
-	struct element *newstart;
-
-	if (!start)
-		return NULL;	/* nothing there */
-
-	if (!start->nextnode)
-		return start;	/* nothing to reverse */
-
-	newstart = dbmail_list_reverse(start->nextnode);	/* reverse rest of list */
-	start->nextnode->nextnode = start;
-
-	start->nextnode = NULL;	/* terminate list */
-
-	return newstart;
+	return g_list_reverse(tlist);
 }
 
 
@@ -90,143 +86,63 @@
  *
  * returns NULL on failure or first element on success
  */
-struct element *list_nodeadd(struct list *tlist, const void *data,
-			     size_t dsize)
+/*done*/
+list *list_nodeadd(list *tlist, gpointer data, size_t dsize)
 {
-	struct element *p;
-
-	if (!tlist)
-		return NULL;	/* cannot add to non-existing list */
-
-	p = tlist->start;
-
-	tlist->start =
-	    (struct element *) my_malloc(sizeof(struct element));
-
-	/* allocating memory */
-#ifdef USE_EXIT_ON_ERROR
-	memtst(tlist->start == NULL);
-	memtst((tlist->start->data = (void *) my_malloc(dsize)) == NULL);
-#else
-	if (!tlist->start)
-		return NULL;
-
-	tlist->start->data = (void *) my_malloc(dsize);
-	if (!tlist->start->data) {
-		my_free(tlist->start);
-		tlist->start = NULL;
+	void * new;
+	new = (gpointer *)my_malloc(dsize);
+	memcpy(new,data,dsize);
+	tlist = g_list_prepend(tlist, new);
+	if(!tlist)
 		return NULL;
-	}
-#endif
-
-	/* copy data */
-	tlist->start->data = memcpy(tlist->start->data, data, dsize);
-	tlist->start->dsize = dsize;
-
-	tlist->start->nextnode = p;
-
-	/* updating node count */
-	tlist->total_nodes++;
-	return tlist->start;
+	return tlist;
 }
 
 
-/*
- * list_nodepop()
- *
- * pops the first element of a linked list
- * ! MEMORY SHOULD BE FREED BY CLIENT !
- */
-struct element *list_nodepop(struct list *list)
+/*done*/
+long list_totalnodes(list *tlist)
 {
-	struct element *ret;
-
-	if (!list || !list->start)
-		return NULL;
-
-	ret = list->start;
-
-	list->start = list->start->nextnode;
-
-	return ret;
+	return g_list_length (tlist);
 }
 
-
-
-/*
- * list_nodedel()
- *
- * removes the item containing 'data' from the list preserving a valid linked-list structure.
- *
- * returns
- */
-struct element *list_nodedel(struct list *tlist, void *data)
+void _list_showlist(gpointer * data, gpointer * temp UNUSED)
 {
-	struct element *temp;
-	struct element *item;
-	item = NULL;
-
-	if (!tlist)
-		return NULL;
-
-	temp = tlist->start;
-
-	/* checking if lists exist else return NULL */
-	if (temp == NULL)
-		return NULL;
+	trace(TRACE_MESSAGE, "list_showlist():item found [%s]\n", (char *) data);
+}
 
-	while (temp != NULL) {	/* walk the list */
-		if (temp->data == data) {
-			if (item == NULL) {
-				tlist->start = temp->nextnode;
-				my_free(temp->data);
-				my_free((struct element *) temp);
-				break;
-			} else {
-				item->nextnode = temp->nextnode;
-				my_free(temp->data);	/* freeing memory */
-				my_free((struct element *) temp);
-				break;
-			}
-			/* updating node count */
-			tlist->total_nodes--;
-		}
-		item = temp;
-		temp = temp->nextnode;
-	}
+void list_showlist(list *tlist)
+{
+	g_list_foreach(tlist, (GFunc)_list_showlist,NULL);
+}
 
+void * list_find(list *tlist, void *fdata) 
+{
+	list *tmp;
+  tmp = g_list_find(tlist, fdata);
+	if(tmp)
+		return tmp->data;
 	return NULL;
 }
 
-
-struct element *list_getstart(struct list *tlist)
+/*done*/
+void list_foreach(list * tlist, GFunc func, gpointer user_data)
 {
-	return (tlist) ? tlist->start : NULL;
+	g_list_foreach(tlist, func, user_data);
 }
 
-
-long list_totalnodes(struct list *tlist)
+/*done*/
+list *list_find_custom(list *tlist, gpointer data, GCompareFunc func)
 {
-	return (tlist) ? tlist->total_nodes : -1;	/* a NULL ptr doesnt even have zero nodes (?) */
+	return g_list_find_custom(tlist,data,func);
 }
 
-
-void list_showlist(struct list *tlist)
+list *list_first(list *tlist)
 {
-	struct element *temp;
-
-	if (!tlist) {
-		trace(TRACE_MESSAGE,
-		      "list_showlist(): NULL ptr received\n");
-		return;
-	}
-
-	temp = tlist->start;
-	while (temp != NULL) {
-		trace(TRACE_MESSAGE, "list_showlist():item found [%s]\n",
-		      (char *) temp->data);
-		temp = temp->nextnode;
-	}
+	return g_list_first(tlist);
+}
+list *list_next(list *tlist)
+{
+	return g_list_next(tlist);
 }
 
 /* basic binary tree */
diff -urNad dbmail-2.1/list.h /tmp/dpep.MIMNv7/dbmail-2.1/list.h
--- dbmail-2.1/list.h	2004-09-14 11:15:04.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/list.h	2004-11-16 09:29:02.000000000 +0100
@@ -30,38 +30,27 @@
 
 #include <sys/types.h>
 
-/*
- * list data types
- */
-struct element {
-	void *data;
-	size_t dsize;
-	struct element *nextnode;
-};
-
-
-struct list {
-	struct element *start;
-	long total_nodes;
-};
-
-
-struct element *list_nodeadd(struct list *tlist, const void *data,
-			     size_t dsize);
+typedef GList list;
 
-struct element *list_nodedel(struct list *tlist, void *data);
-struct element *list_nodepop(struct list *list);
-/*@dependent@*/ struct element *list_getstart(struct list *tlist);
-void list_freelist(struct element **start);
-long list_totalnodes(struct list *tlist);
-void list_showlist(struct list *tlist);
-void list_init(struct list *tlist);
+list *list_nodeadd(list *tlist, gpointer data, size_t dsize);
+void list_freelist(list *tlist);
+long list_totalnodes(list *tlist);
+void list_showlist(list *tlist);
+void list_init(list *tlist);
+void * list_find(list *tlist, void *fdata);
+void list_foreach(list *tlist, GFunc func, gpointer user_data);
+list *list_find_custom(list *tlist, gpointer data, GCompareFunc func);
+list *list_first(list *tlist);
+list *list_next(list *tlist);
 
+/*
+struct element *list_getstart(list *tlist);
+*/
 /* this function had to be renamed because some MySQL versions
  * export a function with the name list_reverse(). Nice of them,
  * but a pretty "strange" way to pollute the global namespace
  */
-struct element *dbmail_list_reverse(struct element *start);
+list *dbmail_list_reverse(list *tlist);
 /* sort stuff */
 
 typedef struct _sortitems
diff -urNad dbmail-2.1/lmtp.c /tmp/dpep.MIMNv7/dbmail-2.1/lmtp.c
--- dbmail-2.1/lmtp.c	2004-10-06 16:08:09.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/lmtp.c	2004-11-16 09:29:02.000000000 +0100
@@ -54,7 +54,7 @@
 #define MAX_IN_BUFFER 255
 
 /* These are needed across multiple calls to lmtp() */
-static struct list rcpt;
+static list *rcpt;
 static char *envelopefrom = NULL;
 
 /* allowed lmtp commands */
@@ -105,9 +105,8 @@
 	 * but only if they were previously
 	 * initialized by LMTP_LHLO... */
 	if (session->state == LHLO) {
-		// list_freelist(&rcpt.start);
-		dsnuser_free_list(&rcpt);
-		list_init(&rcpt);
+		dsnuser_free_list(rcpt);
+		list_init(rcpt);
 	}
 
 	if (envelopefrom != NULL) {
@@ -342,8 +341,7 @@
 				  * */
 				 "250 SIZE\r\n", myhostname);
 			/* Free the recipients list and reinitialize it */
-			// list_freelist( &rcpt.start );
-			list_init(&rcpt);
+			list_init(rcpt);
 			
 			session->state = LHLO;
 			return 1;
@@ -544,7 +542,7 @@
 							dsnuser.address);
 						/* A successfully found recipient goes onto the list.
 						 * The struct will be free'd from lmtp_reset(). */
-						list_nodeadd(&rcpt, &dsnuser,
+						rcpt = list_nodeadd(rcpt, &dsnuser,
 							     sizeof(deliver_to_user_t));
 						break;
 					default:
@@ -566,17 +564,17 @@
 			if (session->state != LHLO) {
 				ci_write((FILE *) stream,
 					"550 Command out of sequence\r\n");
-			} else if (list_totalnodes(&rcpt) < 1) {
+			} else if (list_totalnodes(rcpt) < 1) {
 				ci_write((FILE *) stream,
 					"503 No valid recipients\r\n");
 			} else {
-				if (list_totalnodes(&rcpt) > 0 && envelopefrom != NULL) {
+				if (list_totalnodes(rcpt) > 0 && envelopefrom != NULL) {
 					trace(TRACE_DEBUG,
 					      "main(): requesting sender to begin message.");
 					ci_write((FILE *) stream,
 						"354 Start mail input; end with <CRLF>.<CRLF>\r\n");
 				} else {
-					if (list_totalnodes(&rcpt) < 1) {
+					if (list_totalnodes(rcpt) < 1) {
 						trace(TRACE_DEBUG,
 						      "main(): no valid recipients found, cancel message.");
 						ci_write((FILE *) stream,
@@ -601,19 +599,12 @@
 					u64_t body_size = 0;
 					u64_t rfcsize = 0;
 					u64_t dummyidx = 0, dummysize = 0;
-					struct list fromlist, headerfields;
-					struct element *element;
-					struct list mimelist;
-
-					list_init(&mimelist);
-					list_init(&fromlist);
-					list_init(&headerfields);
+					list *fromlist = NULL, *headerfields = NULL;
+					list *mimelist = NULL;
 
 					/* if (envelopefrom != NULL) */
 					/* We know this to be true from the 354 code, above. */
-					list_nodeadd(&fromlist,
-						     envelopefrom,
-						     strlen(envelopefrom) + 1);
+					fromlist = list_nodeadd(fromlist, envelopefrom, strlen(envelopefrom) + 1);
 					
 					if (read_whole_message_network(
 						    (FILE *) instream,
@@ -684,9 +675,9 @@
 
 					if (insert_messages(
 						    header, body,
-						    headersize, 
-						    body_size, rfcsize,
-						    &headerfields, &rcpt,
+						    headersize, headerrfcsize,
+						    body_size, body_rfcsize,
+						    &headerfields, rcpt,
 						    &fromlist) == -1) {
 						ci_write((FILE *) stream,
 							"503 Message not received\r\n");
@@ -696,14 +687,10 @@
 						const char *class, *subject, *detail;
 
 						/* The replies MUST be in the order received */
-						rcpt.start =
-						    dbmail_list_reverse(rcpt.start);
+						rcpt = dbmail_list_reverse(rcpt);
 
-						for (element = list_getstart(&rcpt);
-						     element != NULL;
-						     element = element->nextnode) {
-							deliver_to_user_t * dsnuser =
-							    (deliver_to_user_t *) element->data;
+						while (rcpt) {
+							deliver_to_user_t * dsnuser = (deliver_to_user_t *) rcpt->data;
 							dsn_tostring(dsnuser->dsn, &class, &subject, &detail);
 
 							/* Give a simple OK, otherwise a detailed message. */
@@ -718,6 +705,7 @@
 									        dsnuser->dsn.class, dsnuser->dsn.subject, dsnuser->dsn.detail,
 									        dsnuser->address, class, subject, detail);
 							}
+							rcpt = list_next(rcpt);
 						}
 					}
 					if (header != NULL)
diff -urNad dbmail-2.1/main.c /tmp/dpep.MIMNv7/dbmail-2.1/main.c
--- dbmail-2.1/main.c	2004-11-15 20:59:52.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/main.c	2004-11-16 09:29:02.000000000 +0100
@@ -52,17 +52,17 @@
 /* syslog */
 #define PNAME "dbmail/smtp"
 
-struct list returnpath;		/* returnpath (should aways be just 1 hop) */
-struct list mimelist;		/* raw unformatted mimefields and values */
-struct list dsnusers;		/* list of deliver_to_user_t structs */
-struct list users;		/* list of email addresses in message */
+list *returnpath = NULL;		/* returnpath (should aways be just 1 hop) */
+list *mimelist = NULL;		/* raw unformatted mimefields and values */
+list *dsnusers = NULL;		/* list of deliver_to_user_t structs */
+list *users = NULL;		/* list of email addresses in message */
 struct element *tmp;
 
 char *configFile = DEFAULT_CONFIG_FILE;
 
 extern db_param_t _db_params;	/* set up database login data */
 
-deliver_to_user_t dsnuser;
+deliver_to_user_t *dsnuser;
 
 //char *header = NULL;
 char *deliver_to_header = NULL;
@@ -138,10 +138,10 @@
 	
 	openlog(PNAME, LOG_PID, LOG_MAIL);
 
-	list_init(&users);
-	list_init(&dsnusers);
-	list_init(&mimelist);
-	list_init(&returnpath);
+	list_init(users);
+	list_init(dsnusers);
+	list_init(mimelist);
+	list_init(returnpath);
 
 	/* Check for commandline options.
 	 * The initial '-' means that arguments which are not associated
@@ -189,9 +189,7 @@
 			      "main(): using RETURN_PATH for bounces");
 
 			/* Add argument onto the returnpath list. */
-			if (list_nodeadd
-			    (&returnpath, optarg,
-			     strlen(optarg) + 1) == 0) {
+			if (! (returnpath = list_nodeadd (returnpath, optarg, strlen(optarg) + 1))) {
 				trace(TRACE_ERROR,
 				      "main(): list_nodeadd reports out of memory"
 				      " while adding to returnpath");
@@ -205,13 +203,11 @@
 			trace(TRACE_INFO,
 			      "main(): using SPECIAL_DELIVERY to usernames");
 
-			dsnuser_init(&dsnuser);
-			dsnuser.address = strdup(optarg);
+			dsnuser_init(dsnuser);
+			dsnuser->address = strdup(optarg);
 
 			/* Add argument onto the users list. */
-			if (list_nodeadd
-			    (&dsnusers, &dsnuser,
-			     sizeof(deliver_to_user_t)) == 0) {
+			if (!(dsnusers = list_nodeadd (dsnusers, dsnuser, sizeof(deliver_to_user_t)))) {
 				trace(TRACE_ERROR,
 				      "main(): list_nodeadd reports out of memory"
 				      " while adding usernames");
@@ -225,13 +221,11 @@
 			trace(TRACE_INFO,
 			      "main(): using SPECIAL_DELIVERY to email addresses");
 
-			dsnuser_init(&dsnuser);
-			dsnuser.address = strdup(optarg);
+			dsnuser_init(dsnuser);
+			dsnuser->address = strdup(optarg);
 
 			/* Add argument onto the users list. */
-			if (list_nodeadd
-			    (&dsnusers, &dsnuser,
-			     sizeof(deliver_to_user_t)) == 0) {
+			if (! (dsnusers = list_nodeadd(dsnusers, dsnuser, sizeof(deliver_to_user_t)))) {
 				trace(TRACE_ERROR,
 				      "main(): list_nodeadd reports out of memory"
 				      " while adding email addresses");
@@ -344,7 +338,7 @@
 	}
 
 	/* parse the list and scan for field and content */
-	if (mime_readheader(header, &dummyidx, &mimelist, &dummysize) < 0) {
+	if (mime_readheader(header, &dummyidx, mimelist, &dummysize) < 0) {
 		trace(TRACE_ERROR,
 		      "main(): mime_readheader failed to read a header list");
 		exitcode = EX_TEMPFAIL;
@@ -352,11 +346,11 @@
 	}
 
 	/* parse returnpath from header */
-	if (returnpath.total_nodes == 0)
-		mail_adr_list("Return-Path", &returnpath, &mimelist);
-	if (returnpath.total_nodes == 0)
-		mail_adr_list("From", &returnpath, &mimelist);
-	if (returnpath.total_nodes == 0)
+	if (list_totalnodes(returnpath) == 0)
+		mail_adr_list("Return-Path", returnpath, mimelist);
+	if (list_totalnodes(returnpath) == 0)
+		mail_adr_list("From", returnpath, mimelist);
+	if (list_totalnodes(returnpath) == 0)
 		trace(TRACE_DEBUG, "main(): no return path found.");
 
 	/* If the NORMAL delivery mode has been selected... */
@@ -364,7 +358,7 @@
 		/* parse for destination addresses */
 		trace(TRACE_DEBUG, "main(): scanning for [%s]",
 		      deliver_to_header);
-		if (mail_adr_list(deliver_to_header, &users, &mimelist) !=
+		if (mail_adr_list(deliver_to_header, users, mimelist) !=
 		    0) {
 			trace(TRACE_STOP,
 			      "main(): scanner found no email addresses (scanned for %s)",
@@ -374,15 +368,15 @@
 		}
 
 		/* Loop through the users list, moving the entries into the dsnusers list. */
-		for (tmp = list_getstart(&users); tmp != NULL;
-		     tmp = tmp->nextnode) {
-			deliver_to_user_t dsnuser;
+		users = list_first(users);
+		while(users) {
+			deliver_to_user_t *dsnuser;
 
-			dsnuser_init(&dsnuser);
-			dsnuser.address = strdup((char *) tmp->data);
+			dsnuser_init(dsnuser);
+			dsnuser->address = strdup((char *) users->data);
 
-			list_nodeadd(&dsnusers, &dsnuser,
-				     sizeof(deliver_to_user_t));
+			dsnusers = list_nodeadd(dsnusers, dsnuser, sizeof(deliver_to_user_t));
+			users = list_next(users);
 		}
 	}
 
@@ -391,13 +385,14 @@
 		trace(TRACE_DEBUG, "main(): setting mailbox for all deliveries to [%s]",
 		      deliver_to_mailbox);
 		/* Loop through the dsnusers list, setting the destination mailbox. */
-		for (tmp = list_getstart(&dsnusers); tmp != NULL;
-		     tmp = tmp->nextnode) {
-			((deliver_to_user_t *)tmp->data)->mailbox = strdup(deliver_to_mailbox);
+		dsnusers = list_first(dsnusers);
+		while(dsnusers) {
+			((deliver_to_user_t *)dsnusers->data)->mailbox = strdup(deliver_to_mailbox);
+			dsnusers = list_next(dsnusers);
 		}
 	}
 
-	if (dsnuser_resolve_list(&dsnusers) == -1) {
+	if (dsnuser_resolve_list(dsnusers) == -1) {
 		trace(TRACE_ERROR, "main(): dsnuser_resolve_list failed");
 		/* Most likely a random failure... */
 		exitcode = EX_TEMPFAIL;
@@ -405,9 +400,9 @@
 	}
 
 	/* inserting messages into the database */
-	if (insert_messages(header, body, headersize,
-			    body_size, rfcsize,
-			    &mimelist, &dsnusers, &returnpath) == -1) {
+	if (insert_messages(header, body, headersize, headerrfcsize,
+			    body_size, body_rfcsize,
+			    mimelist, dsnusers, returnpath) == -1) {
 		trace(TRACE_ERROR, "main(): insert_messages failed");
 		/* Most likely a random failure... */
 		exitcode = EX_TEMPFAIL;
@@ -419,7 +414,7 @@
 	 * then see if one of the status flags was marked with an error. */
 	if (!exitcode) {
 		/* Get one reasonable error code for everyone. */
-		switch (dsnuser_worstcase_list(&dsnusers)) {
+		switch (dsnuser_worstcase_list(dsnusers)) {
 		case DSN_CLASS_OK:
 			exitcode = EX_OK;
 			break;
@@ -433,12 +428,12 @@
 	}
 
 	trace(TRACE_DEBUG, "main(): freeing dsnuser list");
-	dsnuser_free_list(&dsnusers);
+	dsnuser_free_list(dsnusers);
 
 	trace(TRACE_DEBUG, "main(): freeing all other lists");
-	list_freelist(&mimelist.start);
-	list_freelist(&returnpath.start);
-	list_freelist(&users.start);
+	list_freelist(mimelist);
+	list_freelist(returnpath);
+	list_freelist(users);
 
 	trace(TRACE_DEBUG, "main(): freeing memory blocks");
 	if (header != NULL)
diff -urNad dbmail-2.1/mime.c /tmp/dpep.MIMNv7/dbmail-2.1/mime.c
--- dbmail-2.1/mime.c	2004-11-04 14:13:40.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/mime.c	2004-11-16 09:29:02.000000000 +0100
@@ -36,8 +36,8 @@
 /* extern char *header; */
 /* extern u64_t headersize; */
 
-/* extern struct list mimelist;  */
-/* extern struct list users; */
+/* extern list mimelist;  */
+/* extern list users; */
 
 /* checks if s points to the end of a header. */
 static int is_end_of_header(const char *s);
@@ -58,7 +58,7 @@
  *
  * returns -1 on parse failure, -2 on memory error; number of newlines on succes
  */
-int mime_readheader(const char *datablock, u64_t * blkidx, struct list *mimelist,
+int mime_readheader(const char *datablock, u64_t * blkidx, list *mimelist,
 		    u64_t * headersize)
 {
 	int valid_mime_lines = 0, idx, totallines = 0, j;
@@ -69,7 +69,6 @@
 	char *endptr, *startptr, *delimiter;
 	char *blkdata;
 	struct mime_record *mr, *prev_mr = NULL;
-	struct element *el = NULL;
 	int cr_nl_present;	/* 1 if a '\r\n' is found */
 
 	trace(TRACE_DEBUG, "mime_readheader(): entering mime loop");
@@ -191,8 +190,7 @@
 */
 /*	  trace(TRACE_DEBUG,"mime_readheader(): mimepair found: [%s] [%s] \n",mr->field, mr->value); 
 */
-			el = list_nodeadd(mimelist, mr, sizeof(*mr));
-			if (!el) {
+			if (! (*(list **)mimelist = list_nodeadd(*(list **)mimelist, mr, sizeof(*mr)))) {
 				trace(TRACE_ERROR,
 				      "mime_readheader(): cannot add element to list\n");
 				my_free(mr);
@@ -212,14 +210,11 @@
 			 */
 
 			new_add = 1;
-			if (el) {
-				prev_mr =
-				    (struct mime_record *) (el->data);
+			if (mimelist->data) {
+				prev_mr = (struct mime_record *)mimelist->data;
 				prevlen = strlen(prev_mr->value);
 
-				new_add =
-				    (prev_mr->value[prevlen - 1] ==
-				     ';') ? 0 : 1;
+				new_add = (prev_mr->value[prevlen - 1] == ';') ? 0 : 1;
 			}
 
 			if (new_add) {
@@ -237,10 +232,7 @@
 
 				*headersize += 4;	/* <field>: <value>\r\n --> four more */
 
-				el = list_nodeadd(mimelist, mr,
-						  sizeof(*mr));
-
-				if (!el) {
+				if (! (*(list **)mimelist = list_nodeadd(*(list **)mimelist, mr, sizeof(*mr)))) {
 					trace(TRACE_ERROR,
 					      "mime_readheader(): cannot add element to list\n");
 					my_free(mr);
@@ -249,18 +241,13 @@
 				}
 			} else {
 				/* try to add the value to the previous one */
-				if (prevlen <
-				    MIME_VALUE_MAX - (strlen(startptr) +
-						      4)) {
+				if (prevlen < MIME_VALUE_MAX - (strlen(startptr) + 4)) {
 					prev_mr->value[prevlen] = '\n';
 					prev_mr->value[prevlen + 1] = '\t';
 
-					strcpy(&prev_mr->
-					       value[prevlen + 2],
-					       startptr);
+					strcpy(&prev_mr->value[prevlen + 2], startptr);
 
-					*headersize +=
-					    (strlen(startptr) + 2);
+					*headersize += (strlen(startptr) + 2);
 				} else {
 					trace(TRACE_WARNING,
 					      "mime_readheader(): failed adding data (length would exceed "
@@ -279,8 +266,7 @@
 
 		startptr = endptr + 1;	/* advance to next field */
 
-		if (*startptr == '\n'
-		    || (*startptr == '\r' && *(startptr + 1) == '\n')) {
+		if (*startptr == '\n' || (*startptr == '\r' && *(startptr + 1) == '\n')) {
 			/* end of header: double newline */
 			totallines++;
 			(*blkidx)++;
@@ -319,14 +305,11 @@
  * finds a MIME header field
  *
  */
-void mime_findfield(const char *fname, struct list *mimelist,
-		    struct mime_record **mr)
+void mime_findfield(const char *fname, list *mimelist, struct mime_record **mr)
 {
-	struct element *current;
-
-	current = list_getstart(mimelist);
-	while (current) {
-		*mr = current->data;	/* get field/value */
+	mimelist = list_first(mimelist);
+	while (mimelist) {
+		*mr = mimelist->data;	/* get field/value */
 
 //      if (strncasecmp((*mr)->field, fname, strlen(fname)) == 0)
 // some mail is prepended by a line like "From <host> <datetime>"
@@ -334,15 +317,15 @@
 		if (strcasecmp((*mr)->field, fname) == 0)
 			return;	/* found */
 
-		current = current->nextnode;
+		mimelist = g_list_next(mimelist);
 	}
 
 	*mr = NULL;
 }
 
 
-int mail_adr_list(char *scan_for_field, struct list *targetlist,
-		  struct list *mimelist)
+int mail_adr_list(char *scan_for_field, list *targetlist,
+		  list *mimelist)
 {
 	struct element *raw;
 	struct mime_record *mr;
@@ -356,18 +339,17 @@
 
 	trace(TRACE_DEBUG,
 	      "mail_adr_list(): mimelist currently has [%ld] nodes",
-	      mimelist->total_nodes);
+	      list_totalnodes(mimelist));
 
-	memtst((tmpvalue =
-		(char *) calloc(MIME_VALUE_MAX, sizeof(char))) == NULL);
+	memtst((tmpvalue = (char *) calloc(MIME_VALUE_MAX, sizeof(char))) == NULL);
 
 	trace(TRACE_INFO, "mail_adr_list(): mail address parser starting");
 
-	raw = list_getstart(mimelist);
-	trace(TRACE_DEBUG, "mail_adr_list(): total fields in header %ld",
-	      mimelist->total_nodes);
-	while (raw != NULL) {
-		mr = (struct mime_record *) raw->data;
+	mimelist = list_first(mimelist);
+	
+	trace(TRACE_DEBUG, "mail_adr_list(): total fields in header %ld", list_totalnodes(mimelist));
+	while (mimelist) {
+		mr = (struct mime_record *)mimelist->data;
 		trace(TRACE_DEBUG, "mail_adr_list(): scanning for %s",
 		      scan_for_field);
 		if ((strcasecmp(mr->field, scan_for_field) == 0)) {
@@ -399,7 +381,7 @@
 				tmpvalue[ptr - tmp] = '\0';
 
 				/* one extra for \0 in strlen */
-				memtst((list_nodeadd(targetlist, tmpvalue,
+				memtst((*(list **)targetlist = list_nodeadd(*(list **)targetlist, tmpvalue,
 						     (strlen(tmpvalue) +
 						      1))) == NULL);
 
@@ -412,17 +394,17 @@
 				      tmpvalue, ptr ? ptr : "<null>");
 			}
 		}
-		raw = raw->nextnode;
+		mimelist = g_list_next(mimelist);
 	}
 
 	my_free(tmpvalue);
 
 	trace(TRACE_DEBUG, "mail_adr_list(): found %ld emailaddresses",
-	      targetlist->total_nodes);
+	      list_totalnodes(targetlist));
 
 	trace(TRACE_INFO, "mail_adr_list(): mail address parser finished");
 
-	if (targetlist->total_nodes == 0)	/* no addresses found */
+	if (list_totalnodes(targetlist)== 0)	/* no addresses found */
 		return -1;
 
 	return 0;
diff -urNad dbmail-2.1/mime.h /tmp/dpep.MIMNv7/dbmail-2.1/mime.h
--- dbmail-2.1/mime.h	2004-04-14 15:20:31.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/mime.h	2004-11-16 09:29:02.000000000 +0100
@@ -41,11 +41,11 @@
 	char value[MIME_VALUE_MAX];
 };
 
-void mime_findfield(const char *fname, struct list *mimelist,
+void mime_findfield(const char *fname, list *mimelist,
 		    struct mime_record **mr);
-int mail_adr_list(char *scan_for_field, struct list *targetlist,
-		  struct list *mimelist);
+int mail_adr_list(char *scan_for_field, list *targetlist,
+		  list *mimelist);
 int mime_readheader(const char *datablock, u64_t * blkidx, 
-		    struct list *mimelist, u64_t * headersize);
+		    list *mimelist, u64_t * headersize);
 
 #endif
diff -urNad dbmail-2.1/pipe.c /tmp/dpep.MIMNv7/dbmail-2.1/pipe.c
--- dbmail-2.1/pipe.c	2004-11-15 20:59:52.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/pipe.c	2004-11-16 09:29:02.000000000 +0100
@@ -147,9 +147,8 @@
 /*
  * Send an automatic reply using sendmail
  */
-static int send_reply(struct list *headerfields, const char *body)
+static int send_reply(list *headerfields, const char *body)
 {
-	struct element *el;
 	struct mime_record *record;
 	char *from = NULL, *to = NULL, *replyto = NULL, *subject = NULL;
 	FILE *mailpipe = NULL;
@@ -175,10 +174,10 @@
 	      "send_reply(): found sendmail command to be [%s]", sendmail);
 
 	/* find To: and Reply-To:/From: field */
-	el = list_getstart(headerfields);
+	headerfields = list_first(headerfields);
 
-	while (el) {
-		record = (struct mime_record *) el->data;
+	while (headerfields) {
+		record = (struct mime_record *) headerfields->data;
 
 		if (strcasecmp(record->field, "from") == 0) {
 			from = record->value;
@@ -198,8 +197,7 @@
 			trace(TRACE_DEBUG, "send_reply(): found TO [%s]",
 			      to);
 		}
-
-		el = el->nextnode;
+		headerfields = list_next(headerfields);
 	}
 
 	if (!from && !replyto) {
@@ -260,7 +258,7 @@
 
 
 /* Yeah, RAN. That's Reply And Notify ;-) */
-static int execute_auto_ran(u64_t useridnr, struct list *headerfields)
+static int execute_auto_ran(u64_t useridnr, list *headerfields)
 {
 	field_t val;
 	int do_auto_notify = 0, do_auto_reply = 0;
@@ -507,13 +505,15 @@
  *   - -1 on full failure
  */
 int insert_messages(const char *header, const char* body, u64_t headersize,
-		    u64_t bodysize, u64_t rfcsize,
-		    struct list *headerfields,
-		    struct list *dsnusers, struct list *returnpath)
+		    u64_t headerrfcsize, u64_t bodysize, u64_t bodyrfcsize,
+		    list *headerfields,
+		    list *dsnusers, list *returnpath)
 {
-	struct element *element, *ret_path;
-	u64_t msgsize, tmpmsgidnr;
-
+	struct element *ret_path;
+	u64_t msgsize, rfcsize, tmpmsgidnr;
+	
+	list *userids = NULL;
+	
 	msgsize = headersize + bodysize;
 
 	/* first start a new database transaction */
@@ -541,19 +541,20 @@
 	}
 
 	/* Loop through the users list. */
-	for (element = list_getstart(dsnusers); element != NULL;
-	     element = element->nextnode) {
-		struct element *userid_elem;
+	dsnusers = list_first(dsnusers);
+	
+	while (dsnusers) {
+		
 		int has_2 = 0, has_4 = 0, has_5 = 0;
 		deliver_to_user_t *delivery =
-		    (deliver_to_user_t *) element->data;
+		    (deliver_to_user_t *) dsnusers->data;
 		
 		/* Each user may have a list of user_idnr's for local
 		 * delivery. */
-		for (userid_elem = list_getstart(delivery->userids);
-		     userid_elem != NULL;
-		     userid_elem = userid_elem->nextnode) {
-			u64_t useridnr = *(u64_t *) userid_elem->data;
+		userids = list_first(delivery->userids);
+		
+		while (userids) {
+			u64_t useridnr = *(u64_t *) userids->data;
 			trace(TRACE_DEBUG,
 			      "%s, %s: calling sort_and_deliver for useridnr [%llu]",
 			      __FILE__, __func__, useridnr);
@@ -593,6 +594,7 @@
 				trace(TRACE_ERROR, "%s,%s: error in "
 				      "execute_auto_ran(), continuing",
 				      __FILE__, __func__);
+			userids = list_next(userids);
 		}		/* from: the useridnr for loop */
 
 		switch (dsnuser_worstcase_int(has_2, has_4, has_5)) {
@@ -635,20 +637,21 @@
 			      "insert_messages(): delivering to external addresses");
 
 			/* Only the last step of the returnpath is used. */
-			ret_path = list_getstart(returnpath);
+			returnpath = list_first(returnpath);
+			ret_path = returnpath->data;
 
 			/* Forward using the temporary stored message. */
-			if (forward(tmpmsgidnr, delivery->forwards,
-				(ret_path ? ret_path->
-				 data : "DBMAIL-MAILER"), header,
-				headersize) < 0)
+			if (forward(tmpmsgidnr, delivery->forwards, (ret_path ? ret_path : "DBMAIL-MAILER"), header, headersize) < 0)
 				/* FIXME: if forward fails, we should do something 
 				 * sensible. Currently, the message is just black-
 				 * holed! */
 				trace(TRACE_ERROR, "%s,%s: forward failed "
 				      "message lost", __FILE__, __func__);
 		}
-	}			/* from: the delivery for loop */
+		
+		dsnusers = list_next(dsnusers);
+		
+	}			/* from: the delivery while loop */
 
 	/* Always delete the temporary message, even if the delivery failed.
 	 * It is the MTA's job to requeue or bounce the message,
diff -urNad dbmail-2.1/pipe.h /tmp/dpep.MIMNv7/dbmail-2.1/pipe.h
--- dbmail-2.1/pipe.h	2004-10-06 16:08:09.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/pipe.h	2004-11-16 09:29:02.000000000 +0100
@@ -45,9 +45,9 @@
  * \return 0
  */
 int insert_messages(const char *header, const char *body, u64_t headersize, 
-		    u64_t bodysize, u64_t rfcsize,
-		    struct list *headerfields, struct list *dsnusers,
-		    struct list *returnpath);
+		    u64_t headerrfcsize, u64_t bodysize, u64_t bodyrfcsize,
+		    list *headerfields, list *dsnusers,
+		    list *returnpath);
 
 /**
  * \brief discards all input coming from instream
diff -urNad dbmail-2.1/pop3.c /tmp/dpep.MIMNv7/dbmail-2.1/pop3.c
--- dbmail-2.1/pop3.c	2004-09-15 12:23:00.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/pop3.c	2004-11-16 09:29:02.000000000 +0100
@@ -321,11 +321,13 @@
 	u64_t result;
 	int validate_result;
 	u64_t top_lines, top_messageid;
-	struct element *tmpelement;
+	struct message *msg;
 	char *md5_apop_he;
 	char *searchptr;
 	u64_t user_idnr;
 
+	list *messagelst = NULL;
+
 	/* buffer overflow attempt */
 	if (strlen(buffer) > MAX_IN_BUFFER) {
 		trace(TRACE_DEBUG, "pop3(): buffer overflow attempt");
@@ -516,32 +518,21 @@
 				return pop3_error(session, stream,
 						  "-ERR wrong command mode, sir\r\n");
 
-			tmpelement = list_getstart(&session->messagelst);
+			messagelst = list_first(session->messagelst);
 			if (value != NULL) {
 				/* they're asking for a specific message */
-				while (tmpelement != NULL) {
-					if (((struct message *)
-					     tmpelement->data)->
-					    messageid == strtoull(value,
-								  NULL, 10)
-					    && ((struct message *)
-						tmpelement->data)->
-					    virtual_messagestatus < MESSAGE_STATUS_DELETE) {
-						fprintf((FILE *) stream,
-							"+OK %llu %llu\r\n",
-							((struct message *)
-							 tmpelement->
-							 data)->messageid,
-							((struct message *)
-							 tmpelement->
-							 data)->msize);
+				while (messagelst) {
+					msg = (struct message *)messagelst->data;
+					if ((msg->messageid == strtoull(value, NULL, 10))
+							&& (msg->virtual_messagestatus < MESSAGE_STATUS_DELETE)) {
+						fprintf((FILE *) stream, "+OK %llu %llu\r\n", 
+								msg->messageid, msg->msize);
 						found = 1;
 					}
-					tmpelement = tmpelement->nextnode;
+					messagelst = list_next(messagelst);
 				}
 				if (!found)
-					return pop3_error(session, stream,
-							  "-ERR no such message\r\n");
+					return pop3_error(session, stream, "-ERR no such message\r\n");
 				else
 					return 1;
 			}
@@ -554,25 +545,18 @@
 
 			if (session->virtual_totalmessages > 0) {
 				/* traversing list */
-				while (tmpelement != NULL) {
-					if (((struct message *)
-					     tmpelement->data)->
-					    virtual_messagestatus < MESSAGE_STATUS_DELETE)
-						fprintf((FILE *) stream,
-							"%llu %llu\r\n",
-							((struct message *)
-							 tmpelement->
-							 data)->messageid,
-							((struct message *)
-							 tmpelement->
-							 data)->msize);
-					tmpelement = tmpelement->nextnode;
+				
+				while (messagelst) {
+					msg = (struct message *)messagelst->data;
+					if (msg->virtual_messagestatus < MESSAGE_STATUS_DELETE)
+						fprintf((FILE *) stream, "%llu %llu\r\n",
+							msg->messageid, msg->msize);
+					messagelst = list_next(messagelst);
 				}
 			}
 			fprintf((FILE *) stream, ".\r\n");
 			return 1;
 		}
-
 	case POP3_STAT:
 		{
 			if (session->state != POP3_TRANSACTION_STATE)
@@ -595,34 +579,23 @@
 				return pop3_error(session, stream,
 						  "-ERR wrong command mode, sir\r\n");
 
-			tmpelement = list_getstart(&(session->messagelst));
 
 			/* selecting a message */
 			trace(TRACE_DEBUG,
 			      "pop3(): RETR command, selecting message");
-			while (tmpelement != NULL) {
-				if (((struct message *) tmpelement->data)->messageid == strtoull(value, NULL, 10) && ((struct message *) tmpelement->data)->virtual_messagestatus < MESSAGE_STATUS_DELETE) {	/* message is not deleted */
-					((struct message *) tmpelement->
-					 data)->virtual_messagestatus = MESSAGE_STATUS_SEEN;
-					fprintf((FILE *) stream,
-						"+OK %llu octets\r\n",
-						((struct message *)
-						 tmpelement->data)->msize);
-					return
-					    db_send_message_lines((void *)
-								  stream,
-								  ((struct
-								    message
-								    *)
-								   tmpelement->
-								   data)->
-								  realmessageid,
-								  -2, 0);
+			messagelst = list_first(messagelst);
+			while (messagelst) {
+				msg = (struct message *)messagelst->data;
+				if (msg->messageid == strtoull(value, NULL, 10) && 
+						msg->virtual_messagestatus < MESSAGE_STATUS_DELETE) {	/* message is not deleted */
+					msg->virtual_messagestatus = MESSAGE_STATUS_SEEN;
+					fprintf((FILE *) stream, "+OK %llu octets\r\n",
+						msg->msize);
+					return db_send_message_lines((void *)stream, msg->realmessageid, -2, 0);
 				}
-				tmpelement = tmpelement->nextnode;
+				messagelst = list_next(messagelst);
 			}
-			return pop3_error(session, stream,
-					  "-ERR no such message\r\n");
+			return pop3_error(session, stream, "-ERR no such message\r\n");
 		}
 
 	case POP3_DELE:
@@ -631,32 +604,25 @@
 				return pop3_error(session, stream,
 						  "-ERR wrong command mode, sir\r\n");
 
-			tmpelement = list_getstart(&(session->messagelst));
-
 			/* selecting a message */
-			while (tmpelement != NULL) {
-				if (((struct message *) tmpelement->data)->messageid == strtoull(value, NULL, 10) && ((struct message *) tmpelement->data)->virtual_messagestatus < MESSAGE_STATUS_DELETE) {	/* message is not deleted */
-					((struct message *) tmpelement->
-					 data)->virtual_messagestatus = MESSAGE_STATUS_DELETE;
+			messagelst = list_first(messagelst);
+			while (messagelst) {
+				msg = (struct message *)messagelst->data;
+				if (msg->messageid == strtoull(value, NULL, 10) && 
+						msg->virtual_messagestatus < MESSAGE_STATUS_DELETE) {	/* message is not deleted */
+					msg->virtual_messagestatus = MESSAGE_STATUS_DELETE;
 					/* decrease our virtual list fields */
-					session->virtual_totalsize -=
-					    ((struct message *)
-					     tmpelement->data)->msize;
-					session->virtual_totalmessages -=
-					    1;
+					session->virtual_totalsize -= msg->msize;
+					session->virtual_totalmessages -= 1;
 
 					fprintf((FILE *) stream,
 						"+OK message %llu deleted\r\n",
-						((struct message *)
-						 tmpelement->data)->
-						messageid);
+						msg->messageid);
 					return 1;
 				}
-				tmpelement = tmpelement->nextnode;
+				messagelst = list_next(messagelst);
 			}
-			return pop3_error(session, stream,
-					  "-ERR [%s] no such message\r\n",
-					  value);
+			return pop3_error(session, stream, "-ERR [%s] no such message\r\n", value);
 		}
 
 	case POP3_RSET:
@@ -665,18 +631,15 @@
 				return pop3_error(session, stream,
 						  "-ERR wrong command mode, sir\r\n");
 
-			tmpelement = list_getstart(&(session->messagelst));
 
 			session->virtual_totalsize = session->totalsize;
-			session->virtual_totalmessages =
-			    session->totalmessages;
+			session->virtual_totalmessages = session->totalmessages;
 
-			while (tmpelement != NULL) {
-				((struct message *) tmpelement->data)->
-				    virtual_messagestatus =
-				    ((struct message *) tmpelement->data)->
-				    messagestatus;
-				tmpelement = tmpelement->nextnode;
+			messagelst = list_first(messagelst);
+			while (messagelst) {
+				msg = (struct message *)messagelst->data;
+				msg->virtual_messagestatus = msg->messagestatus;
+				messagelst = list_next(messagelst);
 			}
 
 			fprintf((FILE *) stream,
@@ -693,20 +656,18 @@
 				return pop3_error(session, stream,
 						  "-ERR wrong command mode, sir\r\n");
 
-			tmpelement = list_getstart(&(session->messagelst));
+			messagelst = list_first(messagelst);
 
-			while (tmpelement != NULL) {
-				if (((struct message *) tmpelement->data)->
-				    virtual_messagestatus == MESSAGE_STATUS_NEW) {
+			while (messagelst) {
+				msg = (struct message *)messagelst->data;
+				if (msg->virtual_messagestatus == MESSAGE_STATUS_NEW) {
 					/* we need the last message that has been accessed */
 					fprintf((FILE *) stream,
 						"+OK %llu\r\n",
-						((struct message *)
-						 tmpelement->data)->
-						messageid - 1);
+						msg->messageid - 1);
 					return 1;
 				}
-				tmpelement = tmpelement->nextnode;
+				messagelst = list_next(messagelst);
 			}
 
 			/* all old messages */
@@ -732,29 +693,20 @@
 				return pop3_error(session, stream,
 						  "-ERR wrong command mode, sir\r\n");
 
-			tmpelement = list_getstart(&(session->messagelst));
 
 			if (value != NULL) {
 				/* they're asking for a specific message */
-				while (tmpelement != NULL) {
-					if (((struct message *)
-					     tmpelement->data)->
-					    messageid == strtoull(value,
-								  NULL, 10)
-					    && ((struct message *)
-						tmpelement->data)->
-					    virtual_messagestatus < MESSAGE_STATUS_DELETE) {
+				messagelst = list_first(messagelst);
+				while (messagelst) {
+					msg = (struct message *)messagelst->data;
+					if ((msg->messageid == strtoull(value, NULL, 10))
+					    && (msg->virtual_messagestatus < MESSAGE_STATUS_DELETE)) {
 						fprintf((FILE *) stream,
 							"+OK %llu %s\r\n",
-							((struct message *)
-							 tmpelement->
-							 data)->messageid,
-							((struct message *)
-							 tmpelement->
-							 data)->uidl);
+							msg->messageid, msg->uidl);
 						found = 1;
 					}
-					tmpelement = tmpelement->nextnode;
+					messagelst = list_next(messagelst);
 				}
 				if (!found)
 					return pop3_error(session, stream,
@@ -764,25 +716,20 @@
 			}
 
 			/* just drop the list */
-			fprintf((FILE *) stream,
-				"+OK Some very unique numbers for you\r\n");
+			fprintf((FILE *) stream, "+OK Some very unique numbers for you\r\n");
 
 			if (session->virtual_totalmessages > 0) {
 				/* traversing list */
-				while (tmpelement != NULL) {
-					if (((struct message *)
-					     tmpelement->data)->
-					    virtual_messagestatus < MESSAGE_STATUS_DELETE)
+				messagelst = list_first(messagelst);
+				while (messagelst) {
+					msg = (struct message *)messagelst->data;
+					if (msg->virtual_messagestatus < MESSAGE_STATUS_DELETE)
 						fprintf((FILE *) stream,
 							"%llu %s\r\n",
-							((struct message *)
-							 tmpelement->
-							 data)->messageid,
-							((struct message *)
-							 tmpelement->
-							 data)->uidl);
+							msg->messageid,
+							msg->uidl);
 
-					tmpelement = tmpelement->nextnode;
+					messagelst = list_next(messagelst);
 				}
 			}
 
@@ -992,29 +939,23 @@
 			trace(TRACE_DEBUG,
 			      "pop3():TOP command (partially) retrieving message");
 
-			tmpelement = list_getstart(&(session->messagelst));
 
 			/* selecting a message */
 			trace(TRACE_DEBUG,
 			      "pop3(): TOP command, selecting message");
 
-			while (tmpelement != NULL) {
-				if (((struct message *) tmpelement->data)->messageid == top_messageid && ((struct message *) tmpelement->data)->virtual_messagestatus < MESSAGE_STATUS_DELETE) {	/* message is not deleted */
+			messagelst = list_first(messagelst);
+			while (messagelst) {
+				msg = (struct message *)messagelst->data;
+				if (msg->messageid == top_messageid && msg->virtual_messagestatus < MESSAGE_STATUS_DELETE) {
+					/* message is not deleted */
 					fprintf((FILE *) stream,
 						"+OK %llu lines of message %llu\r\n",
 						top_lines, top_messageid);
 					return
-					    db_send_message_lines(stream,
-								  ((struct
-								    message
-								    *)
-								   tmpelement->
-								   data)->
-								  realmessageid,
-								  top_lines,
-								  0);
+					    db_send_message_lines(stream, msg->realmessageid, top_lines, 0);
 				}
-				tmpelement = tmpelement->nextnode;
+				messagelst = list_next(messagelst);
 			}
 			return pop3_error(session, stream,
 					  "-ERR no such message\r\n");
diff -urNad dbmail-2.1/rfcmsg.c /tmp/dpep.MIMNv7/dbmail-2.1/rfcmsg.c
--- dbmail-2.1/rfcmsg.c	2004-10-08 11:58:51.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/rfcmsg.c	2004-11-16 09:29:02.000000000 +0100
@@ -42,28 +42,20 @@
  */
 void db_free_msg(mime_message_t * msg)
 {
-	struct element *tmp;
-
 	if (!msg)
 		return;
 
 	/* free the children msg's */
-	tmp = list_getstart(&msg->children);
+	msg->children = list_first(msg->children);	
 
-	while (tmp) {
-		db_free_msg((mime_message_t *) tmp->data);
-		tmp = tmp->nextnode;
+	while (msg->children) {
+		db_free_msg((mime_message_t *)msg->children->data);
+		msg->children = list_next(msg->children);	
 	}
 
-	tmp = list_getstart(&msg->children);
-	list_freelist(&tmp);
-
-	tmp = list_getstart(&msg->mimeheader);
-	list_freelist(&tmp);
-
-	tmp = list_getstart(&msg->rfcheader);
-	list_freelist(&tmp);
-
+	list_freelist(msg->children);
+	list_freelist(msg->mimeheader);
+	list_freelist(msg->rfcheader);
 	memset(msg, 0, sizeof(*msg));
 }
 
@@ -73,25 +65,22 @@
  */
 void db_reverse_msg(mime_message_t * msg)
 {
-	struct element *tmp;
-
 	if (!msg)
 		return;
-
 	/* reverse the children msg's */
-	tmp = list_getstart(&msg->children);
+	msg->children = list_first(msg->children);
 
-	while (tmp) {
-		db_reverse_msg((mime_message_t *) tmp->data);
-		tmp = tmp->nextnode;
+	while (msg->children) {
+		db_reverse_msg((mime_message_t *)msg->children->data);
+		msg->children = list_next(msg->children);
 	}
 
 	/* reverse this list */
-	msg->children.start = dbmail_list_reverse(msg->children.start);
+	msg->children = dbmail_list_reverse(msg->children);
 
 	/* reverse header items */
-	msg->mimeheader.start = dbmail_list_reverse(msg->mimeheader.start);
-	msg->rfcheader.start = dbmail_list_reverse(msg->rfcheader.start);
+	msg->mimeheader = dbmail_list_reverse(msg->mimeheader);
+	msg->rfcheader = dbmail_list_reverse(msg->rfcheader);
 }
 
 /*
@@ -231,7 +220,7 @@
 	trace(TRACE_DEBUG, "db_start_msg(): starting, stopbound: '%s'\n",
 	      stopbound ? stopbound : "<null>");
 
-	list_init(&msg->children);
+	list_init(msg->children);
 	msg->message_has_errors = (!continue_recursion);
 
 
@@ -241,13 +230,13 @@
 
 	if ((hdrlines =
 	     mime_readheader(&msgbuf_buf[msgbuf_idx], &msgbuf_idx,
-			     &msg->rfcheader, &msg->rfcheadersize)) < 0)
+			     msg->rfcheader, &msg->rfcheadersize)) < 0)
 		return hdrlines;	/* error reading header */
 
 	db_give_msgpos(&msg->bodystart);
 	msg->rfcheaderlines = hdrlines;
 
-	mime_findfield("content-type", &msg->rfcheader, &mr);
+	mime_findfield("content-type", msg->rfcheader, &mr);
 	if (continue_recursion &&
 	    mr
 	    && strncasecmp(mr->value, "multipart",
@@ -329,7 +318,7 @@
 		/* find MIME-parts */
 		(*level)++;
 		if ((nlines =
-		     db_add_mime_children(&msg->children, newbound, level,
+		     db_add_mime_children(msg->children, newbound, level,
 					  maxlevel)) < 0) {
 			trace(TRACE_WARNING,
 			      "db_start_msg(): error adding MIME-children\n");
@@ -383,10 +372,8 @@
 					       stopbound, sblen) == 0) {
 					db_give_msgpos(&msg->bodyend);
 					msg->bodysize =
-					    db_give_range_size(&msg->
-							       bodystart,
-							       &msg->
-							       bodyend);
+					    db_give_range_size(&msg->bodystart,
+							       &msg->bodyend);
 
 					msgbuf_idx++;	/* msgbuf_buf[msgbuf_idx] == '-' now */
 
@@ -466,10 +453,10 @@
  * assume to enter just after a splitbound 
  * returns -1 on parse error, -2 on dbase error, -3 on memory error
  */
-int db_add_mime_children(struct list *brothers, char *splitbound,
+int db_add_mime_children(list *siblings, char *splitbound,
 			 int *level, int maxlevel)
 {
-	mime_message_t part;
+	mime_message_t *part = (mime_message_t *)my_malloc(sizeof(mime_message_t));
 	struct mime_record *mr;
 	int sblen, nlines, totallines = 0, len;
 	u64_t dummy;
@@ -484,21 +471,21 @@
 
 	do {
 		db_update_msgbuf(MSGBUF_FORCE_UPDATE);
-		memset(&part, 0, sizeof(part));
-		part.message_has_errors = (!continue_recursion);
+		memset(part, 0, sizeof(part));
+		part->message_has_errors = (!continue_recursion);
 
 		/* should have a MIME header right here */
 		if ((nlines =
 		     mime_readheader(&msgbuf_buf[msgbuf_idx], &msgbuf_idx,
-				     &part.mimeheader, &dummy)) < 0) {
+				     part->mimeheader, &dummy)) < 0) {
 			trace(TRACE_WARNING,
 			      "db_add_mime_children(): error reading MIME-header\n");
-			db_free_msg(&part);
+			db_free_msg(part);
 			return nlines;	/* error reading header */
 		}
 		totallines += nlines;
 
-		mime_findfield("content-type", &part.mimeheader, &mr);
+		mime_findfield("content-type", part->mimeheader, &mr);
 
 		if (continue_recursion &&
 		    mr
@@ -509,18 +496,18 @@
 
 			/* a message will follow */
 			if ((nlines =
-			     db_start_msg(&part, splitbound, level,
+			     db_start_msg(part, splitbound, level,
 					  maxlevel)) < 0) {
 				trace(TRACE_WARNING,
 				      "db_add_mime_children(): error retrieving message\n");
-				db_free_msg(&part);
+				db_free_msg(part);
 				return nlines;
 			}
 			trace(TRACE_DEBUG,
 			      "db_add_mime_children(): got %d newlines from start_msg()\n",
 			      nlines);
 			totallines += nlines;
-			part.mimerfclines = nlines;
+			part->mimerfclines = nlines;
 		} else if (continue_recursion &&
 			   mr
 			   && strncasecmp(mr->value, "multipart",
@@ -538,7 +525,7 @@
 			if (!bptr) {
 				trace(TRACE_WARNING,
 				      "db_add_mime_children(): could not find a new msg-boundary\n");
-				db_free_msg(&part);
+				db_free_msg(part);
 				return -1;	/* no new boundary ??? */
 			}
 
@@ -559,7 +546,7 @@
 			if (!(newbound = (char *) my_malloc(len + 1))) {
 				trace(TRACE_ERROR,
 				      "db_add_mime_children(): out of memory\n");
-				db_free_msg(&part);
+				db_free_msg(part);
 				return -3;
 			}
 
@@ -575,7 +562,7 @@
 			if (db_update_msgbuf(MSGBUF_FORCE_UPDATE) == -1) {
 				trace(TRACE_ERROR,
 				      "db_add_mime_children(): error updating msgbuf\n");
-				db_free_msg(&part);
+				db_free_msg(part);
 				my_free(newbound);
 				return -2;
 			}
@@ -588,7 +575,7 @@
 
 				if (msgbuf_buf[msgbuf_idx] == '\n') {
 					totallines++;
-					part.bodylines++;
+					part->bodylines++;
 				}
 
 				msgbuf_idx++;
@@ -598,24 +585,24 @@
 				trace(TRACE_WARNING,
 				      "db_add_mime_children(): unexpected end-of-data\n");
 				my_free(newbound);
-				db_free_msg(&part);
+				db_free_msg(part);
 				return -1;
 			}
 
 			msgbuf_idx += strlen(newbound);	/* skip the boundary */
 			msgbuf_idx++;	/* skip \n */
 			totallines++;	/* and count it */
-			part.bodylines++;
-			db_give_msgpos(&part.bodystart);	/* remember position */
+			part->bodylines++;
+			db_give_msgpos(&part->bodystart);	/* remember position */
 
 			(*level)++;
 			if ((nlines =
-			     db_add_mime_children(&part.children, newbound,
+			     db_add_mime_children(part->children, newbound,
 						  level, maxlevel)) < 0) {
 				trace(TRACE_WARNING,
 				      "db_add_mime_children(): error adding mime children\n");
 				my_free(newbound);
-				db_free_msg(&part);
+				db_free_msg(part);
 				return nlines;
 			}
 			(*level)--;
@@ -627,32 +614,30 @@
 			if (msgbuf_idx > 0) {
 				/* walk back because bodyend is inclusive */
 				msgbuf_idx--;
-				db_give_msgpos(&part.bodyend);
+				db_give_msgpos(&part->bodyend);
 				msgbuf_idx++;
 			} else
-				db_give_msgpos(&part.bodyend);	/* this case should never happen... */
+				db_give_msgpos(&part->bodyend);	/* this case should never happen... */
 
 
-			part.bodysize =
-			    db_give_range_size(&part.bodystart,
-					       &part.bodyend);
-			part.bodylines += nlines;
+			part->bodysize = db_give_range_size(&part->bodystart, &part->bodyend);
+			part->bodylines += nlines;
 			totallines += nlines;
 		} else {
 			trace(TRACE_DEBUG,
 			      "db_add_mime_children(): expecting body data...\n");
 
 			/* just body data follows, advance to splitbound */
-			db_give_msgpos(&part.bodystart);
+			db_give_msgpos(&part->bodystart);
 
 			while (msgbuf_buf[msgbuf_idx]) {
 				if (db_update_msgbuf(sblen + 3) == -1) {
-					db_free_msg(&part);
+					db_free_msg(part);
 					return -2;
 				}
 
 				if (msgbuf_buf[msgbuf_idx] == '\n')
-					part.bodylines++;
+					part->bodylines++;
 
 				if (msgbuf_buf[msgbuf_idx + 1] == '-'
 				    && msgbuf_buf[msgbuf_idx + 2] == '-'
@@ -668,30 +653,28 @@
 			 * or the character right before '--<splitbound>'
 			 */
 
-			totallines += part.bodylines;
+			totallines += part->bodylines;
 
 			if (!msgbuf_buf[msgbuf_idx]) {
 				trace(TRACE_WARNING,
 				      "db_add_mime_children(): unexpected end of data\n");
-				db_free_msg(&part);
+				db_free_msg(part);
 				return -1;	/* ?? splitbound should follow */
 			}
 
-			db_give_msgpos(&part.bodyend);
-			part.bodysize =
-			    db_give_range_size(&part.bodystart,
-					       &part.bodyend);
+			db_give_msgpos(&part->bodyend);
+			part->bodysize = db_give_range_size(&part->bodystart, &part->bodyend);
 
 			msgbuf_idx++;	/* msgbuf_buf[msgbuf_idx] == '-' after this statement */
 
 			msgbuf_idx += sblen + 2;	/* skip the boundary & double hypen */
 		}
 
-		/* add this part to brother list */
-		if (list_nodeadd(brothers, &part, sizeof(part)) == NULL) {
+		/* add this part to sibling list */
+		if (! (*(list **)siblings = list_nodeadd(*(list **)siblings, part, sizeof(part)) == NULL)) {
 			trace(TRACE_WARNING,
 			      "db_add_mime_children(): could not add node\n");
-			db_free_msg(&part);
+			db_free_msg(part);
 			return -3;
 		}
 
@@ -746,7 +729,6 @@
 {
 	int result;
 	struct mime_record mr;
-	struct element *el = NULL;
 	field_t postmaster;
 
 	memset(msg, 0, sizeof(*msg));
@@ -754,15 +736,15 @@
 	strcpy(mr.field, "subject");
 	strcpy(mr.value,
 	       "dbmail IMAP server info: this message could not be parsed");
-	el = list_nodeadd(&msg->rfcheader, &mr, sizeof(mr));
-	if (!el)
+	msg->rfcheader = list_nodeadd(msg->rfcheader, &mr, sizeof(mr));
+	if (!msg->rfcheader)
 		return -3;
 
 	strcpy(mr.field, "from");
 	GetConfigValue("POSTMASTER", "DBMAIL", postmaster);
 	strncpy(mr.value, postmaster, MIME_VALUE_MAX - 1);
-	el = list_nodeadd(&msg->rfcheader, &mr, sizeof(mr));
-	if (!el)
+	msg->rfcheader = list_nodeadd(msg->rfcheader, &mr, sizeof(mr));
+	if (!msg->rfcheader)
 		return -3;
 
 	msg->rfcheadersize =
@@ -808,7 +790,6 @@
  */
 int db_msgdump(mime_message_t * msg, u64_t msguid, int level)
 {
-	struct element *curr;
 	struct mime_record *mr;
 	char *spaces;
 	int size = sizeof(mime_message_t);
@@ -830,30 +811,30 @@
 
 
 	trace(TRACE_DEBUG, "%sMIME-header: \n", spaces);
-	curr = list_getstart(&msg->mimeheader);
-	if (!curr)
+	msg->mimeheader = list_first(msg->mimeheader);
+	if (! msg->mimeheader)
 		trace(TRACE_DEBUG, "%s%snull\n", spaces, spaces);
 	else {
-		while (curr) {
-			mr = (struct mime_record *) curr->data;
+		while (msg->mimeheader) {
+			mr = (struct mime_record *)msg->mimeheader->data;
 			trace(TRACE_DEBUG, "%s%s[%s] : [%s]\n", spaces,
 			      spaces, mr->field, mr->value);
-			curr = curr->nextnode;
+			msg->mimeheader = list_next(msg->mimeheader);
 			size += sizeof(struct mime_record);
 		}
 	}
 	trace(TRACE_DEBUG, "%s*** MIME-header end\n", spaces);
 
 	trace(TRACE_DEBUG, "%sRFC822-header: \n", spaces);
-	curr = list_getstart(&msg->rfcheader);
-	if (!curr)
+	msg->rfcheader = list_first(msg->rfcheader);
+	if (! msg->rfcheader)
 		trace(TRACE_DEBUG, "%s%snull\n", spaces, spaces);
 	else {
-		while (curr) {
-			mr = (struct mime_record *) curr->data;
+		while (msg->rfcheader) {
+			mr = (struct mime_record *)msg->rfcheader->data;
 			trace(TRACE_DEBUG, "%s%s[%s] : [%s]\n", spaces,
 			      spaces, mr->field, mr->value);
-			curr = curr->nextnode;
+			msg->rfcheader = list_next(msg->rfcheader);
 			size += sizeof(struct mime_record);
 		}
 	}
@@ -873,12 +854,10 @@
 */
 	trace(TRACE_DEBUG, "%sChildren of this msg:\n", spaces);
 
-	curr = list_getstart(&msg->children);
-	while (curr) {
-		size +=
-		    db_msgdump((mime_message_t *) curr->data, msguid,
-			       level + 1);
-		curr = curr->nextnode;
+	msg->children = list_first(msg->children);
+	while (msg->children) {
+		size += db_msgdump((mime_message_t *)msg->children->data, msguid, level + 1);
+		msg->children = list_next(msg->children);
 	}
 	trace(TRACE_DEBUG, "%s*** child list end\n", spaces);
 
diff -urNad dbmail-2.1/rfcmsg.h /tmp/dpep.MIMNv7/dbmail-2.1/rfcmsg.h
--- dbmail-2.1/rfcmsg.h	2004-03-19 17:27:38.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/rfcmsg.h	2004-11-16 09:29:02.000000000 +0100
@@ -38,7 +38,7 @@
 void db_reverse_msg(mime_message_t * msg);
 
 int db_fetch_headers(u64_t msguid, mime_message_t * msg);
-int db_add_mime_children(struct list *brothers, char *splitbound,
+int db_add_mime_children(list *brothers, char *splitbound,
 			 int *level, int maxlevel);
 int db_start_msg(mime_message_t * msg, char *stopbound, int *level,
 		 int maxlevel);
diff -urNad dbmail-2.1/serverchild.c /tmp/dpep.MIMNv7/dbmail-2.1/serverchild.c
--- dbmail-2.1/serverchild.c	2004-11-16 09:26:54.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/serverchild.c	2004-11-16 09:29:02.000000000 +0100
@@ -1,5 +1,5 @@
 /*
-  $Id$
+  $Id$
  Copyright (C) 1999-2004 IC & S  dbmail@ic-s.nl
 
  This program is free software; you can redistribute it and/or 
@@ -98,9 +98,7 @@
 
 void noop_child_sig_handler(int sig, siginfo_t *info UNUSED, void *data UNUSED)
 {
-	if (sig == SIGSEGV)
-		_exit(0);
-	trace(TRACE_DEBUG, "%s,%s: ignoring signal [%d]", __FILE__, __FUNCTION__, sig);
+       trace(TRACE_DEBUG, "%s,%s: ignoring signal [%d]", __FILE__, __FUNCTION__, sig);
 }
 
 void active_child_sig_handler(int sig, siginfo_t * info UNUSED, void *data UNUSED)
diff -urNad dbmail-2.1/sievecmd.c /tmp/dpep.MIMNv7/dbmail-2.1/sievecmd.c
--- dbmail-2.1/sievecmd.c	2004-11-04 12:03:02.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/sievecmd.c	2004-11-16 09:29:02.000000000 +0100
@@ -53,7 +53,7 @@
 
 int main(int argc, char *argv[])
 {
-	serverConfig_t sysItems;
+	list sysItems;
 	int res = 0, opt = 0, act = 0;
 	u64_t user_idnr = 0;
 	char *user_name = NULL;
@@ -269,7 +269,7 @@
 
 int do_list(u64_t user_idnr)
 {
-	struct list scriptlist;
+	list scriptlist;
 	struct element *tmp;
 
 	if (db_get_sievescript_listall(user_idnr, &scriptlist) < 0) {
diff -urNad dbmail-2.1/sort/Makefile.am /tmp/dpep.MIMNv7/dbmail-2.1/sort/Makefile.am
--- dbmail-2.1/sort/Makefile.am	2004-10-14 22:51:00.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/sort/Makefile.am	2004-11-16 09:29:02.000000000 +0100
@@ -21,7 +21,7 @@
 
 if SIEVE
 libsortdbmail_la_SOURCES = sort.c sortsieve.c
-AM_CFLAGS = -DSIEVE
+AM__CFLAGS += -DSIEVE
 else
 libsortdbmail_la_SOURCES = sort.c
 endif
diff -urNad dbmail-2.1/sort/sort.c /tmp/dpep.MIMNv7/dbmail-2.1/sort/sort.c
--- dbmail-2.1/sort/sort.c	2004-06-03 14:41:55.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/sort/sort.c	2004-11-16 09:29:02.000000000 +0100
@@ -65,11 +65,9 @@
 {
 	field_t val;
 	int do_regex = 0, do_sieve = 0;
-	struct list actions;
-	struct element *tmp;
-	int actiontaken = 0, ret = 0;
+	list actions;
+	int actiontaken = 0;
 	u64_t mboxidnr, newmsgidnr;
-	char unique_id[UID_SIZE];
 	char *inbox = "INBOX";
 
 
@@ -110,7 +108,49 @@
 
 	if (mailbox == NULL)
 		mailbox = inbox;
+	/* This is that implicit keep I mentioned earlier...
+	 * If possible, put the message in the specified
+	 * mailbox, otherwise use INBOX. */
+	if (actiontaken == 0) {
+		/* Did we fail to create the mailbox? */
+		if (db_find_create_mailbox(mailbox, useridnr, &mboxidnr) !=
+		    0) {
+			/* Serious failure situation! */
+			trace(TRACE_ERROR,
+			      "sort_and_deliver(): INBOX not found");
+		} else {
+			switch (db_copymsg
+				(msgidnr, mboxidnr, useridnr,
+				 &newmsgidnr)) {
+			case -2:
+				/* Couldn't deliver because the quotum is exceeded. */
+				trace(TRACE_DEBUG,
+				      "%s, %s: error copying message to user [%llu], maxmail exceeded",
+				      __FILE__, __func__, useridnr);
+				break;
+			case -1:
+				/* Couldn't deliver because something something went wrong. */
+				trace(TRACE_ERROR,
+				      "%s, %s: error copying message to user [%llu]",
+				      __FILE__, __func__, useridnr);
+				break;
+			default:
+				trace(TRACE_MESSAGE,
+				      "%s, %s: message id=%llu, size=%llu is inserted",
+				      __FILE__, __func__, newmsgidnr,
+				      totalmsgsize);
+				actiontaken = 1;
+				break;
+			}
+		}
+	}
+
+	if (actiontaken)
+		return DSN_CLASS_OK;
+	return DSN_CLASS_TEMP;
+}
 
+int get_actions(list actions) {
 	/* actions is a list of things to do with this message
 	 * each data pointer in the actions list references
 	 * a structure like this:
@@ -146,7 +186,7 @@
 	 * actions fail...) an implicit SA_KEEP is performed,
 	 * using INBOX as the destination (hardcoded).
 	 * */
-
+#ifdef OLD
 	if (list_totalnodes(&actions) > 0) {
 		tmp = list_getstart(&actions);
 		while (tmp != NULL) {
@@ -162,7 +202,7 @@
 					if ((char *) ((sort_action_t *)
 						      tmp->data)->
 					    destination != NULL) {
-						struct list localtmplist;
+						list localtmplist;
 						struct element
 						    *localtmpelem;
 //                      if (sortsieve_msgsort(useridnr, header, headersize, (char *)((sort_action_t *)tmp->data)->destination, localtmplist))
@@ -289,7 +329,7 @@
 			case SA_REDIRECT:
 				{
 					char *forward_id;
-					struct list targets;
+					list targets;
 
 					list_init(&targets);
 					list_nodeadd(&targets,
@@ -333,45 +373,8 @@
 		/* Might as well be explicit about this... */
 		actiontaken = 0;
 	}
+#endif
+	return 0;
+}
 
-	/* This is that implicit keep I mentioned earlier...
-	 * If possible, put the message in the specified
-	 * mailbox, otherwise use INBOX. */
-	if (actiontaken == 0) {
-		/* Did we fail to create the mailbox? */
-		if (db_find_create_mailbox(mailbox, useridnr, &mboxidnr) !=
-		    0) {
-			/* Serious failure situation! */
-			trace(TRACE_ERROR,
-			      "sort_and_deliver(): INBOX not found");
-		} else {
-			switch (db_copymsg
-				(msgidnr, mboxidnr, useridnr,
-				 &newmsgidnr)) {
-			case -2:
-				/* Couldn't deliver because the quotum is exceeded. */
-				trace(TRACE_DEBUG,
-				      "%s, %s: error copying message to user [%llu], maxmail exceeded",
-				      __FILE__, __func__, useridnr);
-				break;
-			case -1:
-				/* Couldn't deliver because something something went wrong. */
-				trace(TRACE_ERROR,
-				      "%s, %s: error copying message to user [%llu]",
-				      __FILE__, __func__, useridnr);
-				break;
-			default:
-				trace(TRACE_MESSAGE,
-				      "%s, %s: message id=%llu, size=%llu is inserted",
-				      __FILE__, __func__, newmsgidnr,
-				      totalmsgsize);
-				actiontaken = 1;
-				break;
-			}
-		}
-	}
 
-	if (actiontaken)
-		return DSN_CLASS_OK;
-	return DSN_CLASS_TEMP;
-}
diff -urNad dbmail-2.1/sort/sortsieve.c /tmp/dpep.MIMNv7/dbmail-2.1/sort/sortsieve.c
--- dbmail-2.1/sort/sortsieve.c	2004-11-04 12:03:02.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/sort/sortsieve.c	2004-11-16 09:29:02.000000000 +0100
@@ -50,7 +50,7 @@
 #include "sort.h"
 #include <sieve2_interface.h>
 
-extern struct list smtpItems, sysItems;
+extern list smtpItems, sysItems;
 
 /* typedef sort_action {
  *   int method,
@@ -70,7 +70,7 @@
  * finish storing the message and restart.
  * */
 int sortsieve_msgsort(u64_t useridnr, char *header, u64_t headersize,
-		      u64_t messagesize, struct list *actions)
+		      u64_t messagesize, list *actions)
 {
 	sieve2_message_t *m;
 	sieve2_support_t *p;
@@ -214,7 +214,7 @@
 	return ret;
 }
 
-int sortsieve_unroll_action(sieve2_action_t * a, struct list *actions)
+int sortsieve_unroll_action(sieve2_action_t * a, list *actions)
 {
 	int res = SIEVE2_OK;
 	int code;
@@ -327,7 +327,7 @@
 		tmpsa->destination = tmpdest;
 		tmpsa->message = tmpmsg;
 
-		list_nodeadd(actions, tmpsa, sizeof(sort_action_t));
+		*(list **)actions = list_nodeadd(*(list **)actions, tmpsa, sizeof(sort_action_t));
 
 		my_free(tmpsa);
 		tmpsa = NULL;
diff -urNad dbmail-2.1/sort/sortsieve.h /tmp/dpep.MIMNv7/dbmail-2.1/sort/sortsieve.h
--- dbmail-2.1/sort/sortsieve.h	2004-03-19 17:27:38.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/sort/sortsieve.h	2004-11-16 09:29:02.000000000 +0100
@@ -32,8 +32,8 @@
 #define MAX_SIEVE_SCRIPTNAME 100
 
 int sortsieve_msgsort(u64_t useridnr, char *header, u64_t headersize,
-		      u64_t messagesize, struct list *actions);
-int sortsieve_unroll_action(sieve2_action_t * a, struct list *actions);
+		      u64_t messagesize, list *actions);
+int sortsieve_unroll_action(sieve2_action_t * a, list *actions);
 int sortsieve_script_validate(char *script, char **errmsg);
 
 #endif
diff -urNad dbmail-2.1/test-scripts/testimap.py /tmp/dpep.MIMNv7/dbmail-2.1/test-scripts/testimap.py
--- dbmail-2.1/test-scripts/testimap.py	2004-11-04 14:16:27.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/test-scripts/testimap.py	2004-11-16 09:29:02.000000000 +0100
@@ -16,7 +16,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-# $Id$
+# $Id$
 
 import unittest, imaplib, re
 import sys, traceback, getopt
diff -urNad dbmail-2.1/timsieve.c /tmp/dpep.MIMNv7/dbmail-2.1/timsieve.c
--- dbmail-2.1/timsieve.c	2004-07-14 15:10:31.000000000 +0200
+++ /tmp/dpep.MIMNv7/dbmail-2.1/timsieve.c	2004-11-16 09:29:02.000000000 +0100
@@ -806,7 +806,7 @@
 				fprintf((FILE *) stream,
 					"NO \"Please authenticate first.\"\r\n");
 			} else {
-				struct list scriptlist;
+				list scriptlist;
 				struct element *tmp;
 
 				if (db_get_sievescript_listall
diff -urNad dbmail-2.1/user.c /tmp/dpep.MIMNv7/dbmail-2.1/user.c
--- dbmail-2.1/user.c	2004-11-04 12:03:02.000000000 +0100
+++ /tmp/dpep.MIMNv7/dbmail-2.1/user.c	2004-11-16 09:29:02.000000000 +0100
@@ -103,9 +103,9 @@
            const char * const password,
            const char * const enctype,
            const u64_t maxmail, const u64_t clientid,
-	   struct list * const alias_add,
-	   struct list * const alias_del);
-int do_delete(const u64_t useridnr, const char * const user);
+	   list * const alias_add,
+	   list * const alias_del);
+int do_delete(const char * const user);
 int do_show(const char * const user);
 int do_empty(const u64_t useridnr);
 /* Change operations */
@@ -116,12 +116,12 @@
                 const char * const password,
                 const char * const enctype);
 int do_aliases(const u64_t useridnr,
-               struct list * const alias_add,
-               struct list * const alias_del);
+               list * const alias_add,
+               list * const alias_del);
 /* External forwards */
 int do_forwards(const char *alias, const u64_t clientid,
-                struct list * const fwds_add,
-                struct list * const fwds_del);
+                list * const fwds_add,
+                list * const fwds_del);
 
 /* Helper functions */
 int is_valid(const char * const str);
@@ -185,15 +185,10 @@
 	     *passwdfile = NULL;
 	char *password = NULL, *enctype = NULL;
 	u64_t useridnr = 0, clientid = 0, maxmail = 0;
-	struct list alias_add, alias_del, fwds_add, fwds_del;
+	list  *alias_add = NULL, *alias_del = NULL, *fwds_add = NULL, *fwds_del = NULL;
 	struct change_flags change_flags;
 	size_t len = 0;
 
-	list_init(&alias_add);
-	list_init(&alias_del);
-	list_init(&fwds_add);
-	list_init(&fwds_del);
-
 	openlog(PNAME, LOG_PID, LOG_MAIL);
 	setvbuf(stdout, 0, _IONBF, 0);
 
@@ -299,25 +294,25 @@
 		case 's':
 			// Add this item to the user's aliases.
 			if (optarg && (len = strlen(optarg)))
-				list_nodeadd(&alias_add, optarg, len+1);
+				alias_add = list_nodeadd(alias_add, optarg, len+1);
 			break;
 
 		case 'S':
 			// Delete this item from the user's aliases.
 			if (optarg && (len = strlen(optarg)))
-				list_nodeadd(&alias_del, optarg, len+1);
+				alias_del = list_nodeadd(alias_del, optarg, len+1);
 			break;
 
 		case 't':
 			// Add this item to the alias's forwards.
 			if (optarg && (len = strlen(optarg)))
-				list_nodeadd(&fwds_add, optarg, len+1);
+				fwds_add = list_nodeadd(fwds_add, optarg, len+1);
 			break;
 
 		case 'T':
 			// Delete this item from the alias's forwards.
 			if (optarg && (len = strlen(optarg)))
-				list_nodeadd(&fwds_del, optarg, len+1);
+				fwds_del = list_nodeadd(fwds_del, optarg, len+1);
 			break;
 
 		/* Common options */
@@ -406,7 +401,7 @@
 	}
 
 	qprintf("Ok. Connected\n");
-	configure_debug(TRACE_ERROR, 1, 0);
+//	configure_debug(TRACE_ERROR, 1, 0);
 
 	switch (mode) {
 	case 'c':
@@ -476,7 +471,7 @@
 	switch (mode) {
 	case 'a':
 		result = do_add(user, password, enctype, maxmail, clientid,
-				&alias_add, &alias_del);
+				alias_add, alias_del);
 		break;
 	case 'd':
 		result = do_delete(useridnr, user);
@@ -495,7 +490,7 @@
 		if (change_flags.newmaxmail) {
 			result |= do_maxmail(useridnr, maxmail);
 		}
-		result |= do_aliases(useridnr, &alias_add, &alias_del);
+		result |= do_aliases(useridnr, alias_add, alias_del);
 		break;
 	case 'e':
 		result = do_empty(useridnr);
@@ -504,7 +499,7 @@
 		result = do_show(userspec);
 		break;
 	case 'x':
-		result = do_forwards(alias, clientid, &fwds_add, &fwds_del);
+		result = do_forwards(alias, clientid, fwds_add, fwds_del);
 		break;
 	default:
 		result = 1;
@@ -515,14 +510,14 @@
 freeall:
 
 	/* Free the lists. */
-	if (alias_del.start)
-		list_freelist(&alias_del.start);
-	if (alias_add.start)
-		list_freelist(&alias_add.start);
-	if (fwds_del.start)
-		list_freelist(&alias_del.start);
-	if (fwds_add.start)
-		list_freelist(&alias_add.start);
+	if (alias_del)
+		list_freelist(alias_del);
+	if (alias_add)
+		list_freelist(alias_add);
+	if (fwds_del)
+		list_freelist(alias_del);
+	if (fwds_add)
+		list_freelist(alias_add);
 
 	db_disconnect();
 	auth_disconnect();
@@ -536,8 +531,8 @@
 int do_add(const char * const user,
            const char * const password, const char * const enctype,
            const u64_t maxmail, const u64_t clientid,
-	   struct list * const alias_add,
-	   struct list * const alias_del)
+	   list * const alias_add,
+	   list * const alias_del)
 {
 	u64_t useridnr;
 	u64_t mailbox_idnr;
@@ -769,16 +764,16 @@
 }
 
 int do_forwards(const char * const alias, const u64_t clientid,
-                struct list * const fwds_add,
-                struct list * const fwds_del)
+                list * const fwds_add,
+                list * const fwds_del)
 {
 	int result = 0;
 	char *forward;
-	struct element *tmp;
-
+	list *tmp = NULL;
+	
 	/* Delete aliases for the user. */
 	if (fwds_del) {
-		tmp = list_getstart(fwds_del);
+		tmp = list_first(fwds_del);
 		while (tmp) {
 			forward = (char *)tmp->data;
 
@@ -789,13 +784,13 @@
 				     forward);
 				result = -1;
 			}
-			tmp = tmp->nextnode;
+			tmp = list_next(tmp);
 		}
 	}
 
 	/* Add aliases for the user. */
 	if (fwds_add) {
-		tmp = list_getstart(fwds_add);
+		tmp = list_first(fwds_add);
 		while (tmp) {
 			forward = (char *)tmp->data;
 			qprintf("[%s]\n", forward);
@@ -805,7 +800,7 @@
 				     alias);
 				result = -1;
 			}
-			tmp = tmp->nextnode;
+			tmp = list_next(tmp);
 		}
 	}
 
@@ -834,20 +829,19 @@
 }
 
 int do_aliases(const u64_t useridnr,
-               struct list * const alias_add,
-               struct list * const alias_del)
+               list * const alias_add,
+               list * const alias_del)
 {
 	int result = 0;
 	u64_t clientid;
+	list *tmp = NULL;
+	char *alias;
 
 	auth_getclientid(useridnr, &clientid);
 
 	/* Delete aliases for the user. */
 	if (alias_del) {
-		char *alias;
-		struct element *tmp;
-
-		tmp = list_getstart(alias_del);
+		tmp = list_first(alias_del);
 		while (tmp) {
 			alias = (char *)tmp->data;
 
@@ -859,19 +853,16 @@
 				     alias);
 				result = -1;
 			}
-			tmp = tmp->nextnode;
+			tmp = list_next(tmp);
 		}
 	}
 
 	/* Add aliases for the user. */
 	if (alias_add) {
-		char *alias;
-		struct element *tmp;
-		
-
-		tmp = list_getstart(alias_add);
+		tmp = list_first(alias_add);
 		while (tmp) {
 			alias = (char *)tmp->data;
+			
 			qprintf("[%s]\n", alias);
 
 			if (auth_addalias
@@ -880,7 +871,7 @@
 				     alias);
 				result = -1;
 			}
-			tmp = tmp->nextnode;
+			tmp = list_next(tmp);
 		}
 	}
 
@@ -914,8 +905,7 @@
 int do_show(const char * const name)
 {
 	u64_t useridnr, cid, quotum, quotumused;
-	struct list userlist;
-	struct element *tmp;
+	list *userlist = NULL;
 	char *deliver_to;
 
 	if (!name) {
@@ -923,15 +913,16 @@
 		qprintf("Existing users:\n");
 
 		auth_get_known_users(&userlist);
-
-		tmp = list_getstart(&userlist);
-		while (tmp) {
-			qprintf("[%s]\n", (char *) tmp->data);
-			tmp = tmp->nextnode;
+		if (! userlist)
+			qprintf("No users found.\n\n");
+		userlist = list_first(userlist);
+		while (userlist) {
+			qprintf("[%s]\n", (char *)userlist->data);
+			userlist = list_next(userlist);
 		}
 
-		if (userlist.start)
-			list_freelist(&userlist.start);
+		if (userlist)
+			list_freelist(userlist);
 	} else {
 		qprintf("Info for user [%s]", name);
 
@@ -990,17 +981,17 @@
 		qprintf("\n");
 
 		qprintf("Aliases:\n");
-		auth_get_user_aliases(useridnr, &userlist);
+		auth_get_user_aliases(useridnr, userlist);
 
-		tmp = list_getstart(&userlist);
-		while (tmp) {
-			qprintf("%s\n", (char *) tmp->data);
-			tmp = tmp->nextnode;
+		userlist = list_first(userlist);
+		while (userlist) {
+			qprintf("%s\n", (char *)userlist->data);
+			userlist = list_next(userlist);
 		}
 
 		qprintf("\n");
-		if (userlist.start)
-			list_freelist(&userlist.start);
+		if (userlist)
+			list_freelist(userlist);
 	}
 
 	return 0;
