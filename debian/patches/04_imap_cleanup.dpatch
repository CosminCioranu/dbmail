#! /bin/sh -e
## 04_imap_cleanup.dpatch by  <paul@nfg.nl>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p1 ${patch_opts} < $0;;
    -unpatch) patch -R -p1 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

@DPATCH@
diff -urNad /usr/src/dbmail2/dbmail-2.1/dbmail-imapsession.c dbmail-2.1/dbmail-imapsession.c
--- /usr/src/dbmail2/dbmail-2.1/dbmail-imapsession.c	2004-10-21 11:57:56.000000000 +0200
+++ dbmail-2.1/dbmail-imapsession.c	2004-10-21 15:50:38.000000000 +0200
@@ -60,9 +60,6 @@
 /* cache */
 extern cache_t cached_msg;
 
-extern const char AcceptedChars[];
-extern const char AcceptedTagChars[];
-extern const char AcceptedMailboxnameChars[];
 extern const char *month_desc[];
 extern char base64encodestring[];
 /* returned by date_sql2imap() */
@@ -78,13 +75,551 @@
 extern const char *imap_flag_desc[IMAP_NFLAGS];
 extern const char *imap_flag_desc_escaped[IMAP_NFLAGS];
 
-static int dbmail_imap_fetch_parse_partspec(struct ImapSession *self, int idx);
-static int dbmail_imap_fetch_parse_octet_range(struct ImapSession *self, int idx);
+static int _imap_session_fetch_parse_partspec(struct ImapSession *self, int idx);
+static int _imap_session_fetch_parse_octet_range(struct ImapSession *self, int idx);
 
+static GList * _imap_get_structure(mime_message_t * msg, int show_extension_data);
+static GList * _imap_get_addresses(struct mime_record *mr);
+static GList * _imap_get_envelope(struct list *rfcheader);
+static GList * _imap_get_mime_parameters(struct mime_record *mr, int force_subtype, int only_extension);
 
+/* 
+ * _imap_get_structure()
+ *
+ * retrieves the MIME-IMB structure of a message. The msg should be in the format
+ * as build by db_fetch_headers().
+ *
+ * shows extension data if show_extension_data != 0
+ *
+ * returns GList on success, NULL on error
+ */
 
+GList * _imap_get_structure(mime_message_t * msg, int show_extension_data)
+{
+	struct mime_record *mr;
+	struct element *curr;
+	struct list *header_to_use;
+	mime_message_t rfcmsg;
+	char *subtype, *extension, *newline;
+	int is_mime_multipart = 0, is_rfc_multipart = 0;
+	int rfc822 = 0;
+	
+	GList *tlist = NULL, *list = NULL;
+	GString *tmp = g_string_new("");
+	
+	trace(TRACE_DEBUG,"%s,%s", __FILE__,__func__);
+	
+	mime_findfield("content-type", &msg->mimeheader, &mr);
+	is_mime_multipart = (mr
+			     && strncasecmp(mr->value, "multipart", strlen("multipart")) == 0
+			     && !msg->message_has_errors);
 
-static int dbmail_imap_fetch_parse_partspec(struct ImapSession *self, int idx)
+	mime_findfield("content-type", &msg->rfcheader, &mr);
+	is_rfc_multipart = (mr
+			    && strncasecmp(mr->value, "multipart",
+					   strlen("multipart")) == 0
+			    && !msg->message_has_errors);
+
+	/* eddy */
+	if (mr
+	    && strncasecmp(mr->value, "message/rfc822",
+			   strlen("message/rfc822")) == 0) {
+		rfc822 = 1;
+	}
+
+
+	if (rfc822 || (!is_rfc_multipart && !is_mime_multipart)) {
+		/* show basic fields:
+		 * content-type, content-subtype, (parameter list), 
+		 * content-id, content-description, content-transfer-encoding,
+		 * size
+		 */
+
+		if (msg->mimeheader.start == NULL)
+			header_to_use = &msg->rfcheader;	/* we're dealing with a single-part RFC msg here */
+		else
+			header_to_use = &msg->mimeheader;	/* we're dealing with a pure-MIME header here */
+
+		mime_findfield("content-type", header_to_use, &mr);
+		if (mr && strlen(mr->value) > 0) {
+			tlist = _imap_get_mime_parameters(mr, 1, 0);
+			tmp = g_list_join(tlist," ");
+			list = g_list_append(list, g_strdup(tmp->str));
+		} else
+			list = g_list_append(list, "\"TEXT\" \"PLAIN\" (\"CHARSET\" \"US-ASCII\")");	/* default */
+
+		mime_findfield("content-id", header_to_use, &mr);
+		if (mr && strlen(mr->value) > 0) { 
+			list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+		} else
+			list = g_list_append(list, "NIL");
+
+		mime_findfield("content-description", header_to_use, &mr);
+		if (mr && strlen(mr->value) > 0) {
+			list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+		} else
+			list = g_list_append(list, "NIL");
+
+		mime_findfield("content-transfer-encoding", header_to_use,
+			       &mr);
+		if (mr && strlen(mr->value) > 0) {
+			list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+		} else
+			list = g_list_append(list, "\"7BIT\"");
+
+		/* now output size */
+		/* add msg->bodylines because \n is dumped as \r\n */
+		if (msg->mimeheader.start && msg->rfcheader.start)
+			list = g_list_append_printf(list, "%llu",
+				msg->bodysize + msg->mimerfclines +
+				msg->rfcheadersize - msg->rfcheaderlines);
+		else
+			list = g_list_append_printf(list, "%llu",
+				msg->bodysize + msg->bodylines);
+
+
+		/* now check special cases, first case: message/rfc822 */
+		mime_findfield("content-type", header_to_use, &mr);
+		if (mr
+		    && strncasecmp(mr->value, "message/rfc822",
+				   strlen("message/rfc822")) == 0
+		    && header_to_use != &msg->rfcheader) {
+			/* msg/rfc822 found; extra items to be displayed:
+			 * (a) body envelope of rfc822 msg
+			 * (b) body structure of rfc822 msg
+			 * (c) msg size (lines)
+			 */
+
+			tlist = _imap_get_envelope(&msg->rfcheader);
+			list = g_list_append(list, g_strdup(dbmail_imap_plist_as_string(tlist)));
+
+			memmove(&rfcmsg, msg, sizeof(rfcmsg));
+			rfcmsg.mimeheader.start = NULL;	/* forget MIME-part */
+
+			/* start recursion */
+			tlist = _imap_get_structure(&rfcmsg, show_extension_data);
+			list = g_list_append(list, g_strdup(dbmail_imap_plist_as_string(tlist)));
+			
+			/* output # of lines */
+			list = g_list_append_printf(list, "%llu", msg->bodylines);
+		}
+		/* now check second special case: text 
+		 * NOTE: if 'content-type' is absent, TEXT is assumed 
+		 */
+		if ((mr && strncasecmp(mr->value, "text", strlen("text")) == 0) || !mr) {
+			/* output # of lines */
+			if (msg->mimeheader.start && msg->rfcheader.start)
+				list = g_list_append_printf(list, "%llu",
+					msg->mimerfclines);
+			else
+				list = g_list_append_printf(list, "%llu", msg->bodylines);
+		}
+
+		if (show_extension_data) {
+			mime_findfield("content-md5", header_to_use, &mr);
+			if (mr && strlen(mr->value) > 0) {
+				list = g_list_append_printf(list, dbmail_imap_astring_as_string(mr->value));
+			} else
+				list = g_list_append(list, "NIL");
+
+			mime_findfield("content-disposition",
+				       header_to_use, &mr);
+			if (mr && strlen(mr->value) > 0) {
+				tlist = _imap_get_mime_parameters(mr, 0, 0);
+				list = g_list_append(list, g_strdup(dbmail_imap_plist_as_string(tlist)));
+			} else
+				list = g_list_append(list, "NIL");
+
+			mime_findfield("content-language", header_to_use, &mr);
+			if (mr && strlen(mr->value) > 0) {
+				list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+			} else
+				list = g_list_append(list, "NIL");
+		}
+	} else {
+		/* check for a multipart message */
+		if (is_rfc_multipart || is_mime_multipart) {
+			curr = list_getstart(&msg->children);
+			while (curr) {
+				tlist = _imap_get_structure((mime_message_t *) curr->data, show_extension_data);
+				list = g_list_append(list, g_strdup(dbmail_imap_plist_as_string(tlist)));
+
+				curr = curr->nextnode;
+			}
+
+			/* show multipart subtype */
+			if (is_mime_multipart)
+				mime_findfield("content-type", &msg->mimeheader, &mr);
+			else
+				mime_findfield("content-type", &msg->rfcheader, &mr);
+
+			subtype = strchr(mr->value, '/');
+			extension = strchr(subtype, ';');
+
+			if (!subtype)
+				list = g_list_append(list, "NIL");
+			else {
+				if (!extension) {
+					newline = strchr(subtype, '\n');
+					if (!newline)
+						return NULL;
+
+					*newline = 0;
+					list = g_list_append(list, dbmail_imap_astring_as_string(subtype + 1));
+					*newline = '\n';
+				} else {
+					*extension = 0;
+					list = g_list_append(list, dbmail_imap_astring_as_string(subtype + 1));
+					*extension = ';';
+				}
+			}
+
+			/* show extension data (after subtype) */
+			if (extension && show_extension_data) {
+				tlist = _imap_get_mime_parameters(mr, 0, 1);
+				tmp = g_list_join(tlist," ");
+				list = g_list_append(list, g_strdup(tmp->str));
+
+				/* FIXME: should give body-disposition & body-language here */
+				list = g_list_append(list, "NIL NIL");
+			}
+		} else {
+			/* ??? */
+		}
+	}
+	g_list_foreach(tlist,(GFunc)g_free, NULL);
+	g_list_free(tlist);
+	g_string_free(tmp,1);
+	return list;
+}
+
+
+/*
+ * _imap_get_envelope()
+ *
+ * retrieves the body envelope of an RFC-822 msg
+ *
+ * returns GList of char * elements
+ * 
+ */
+static GList * _imap_get_envelope(struct list *rfcheader)
+{
+	struct mime_record *mr;
+	int idx;
+	GList * list = NULL;
+
+	trace(TRACE_DEBUG,"%s,%s", __FILE__,__func__);
+	
+	mime_findfield("date", rfcheader, &mr);
+	if (mr && strlen(mr->value) > 0) 
+		list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+	else
+		list = g_list_append(list, "NIL");
+
+	mime_findfield("subject", rfcheader, &mr);
+	if (mr && strlen(mr->value) > 0)
+		list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+	else
+		list = g_list_append(list, "NIL");
+
+	/* now from, sender, reply-to, to, cc, bcc, in-reply-to fields;
+	 * note that multiple mailaddresses are separated by ','
+	 */
+	GString *tmp = g_string_new("");
+	for (idx = 0; envelope_items[idx]; idx++) {
+		mime_findfield(envelope_items[idx], rfcheader, &mr);
+		if (mr && strlen(mr->value) > 0) {
+			tmp = g_list_join(_imap_get_addresses(mr)," ");
+			g_string_printf(tmp,"(%s)", tmp->str);
+			list = g_list_append(list, g_strdup(tmp->str));
+		} else if (strcasecmp(envelope_items[idx], "reply-to") == 0) {
+			/* default this field */
+			mime_findfield("from", rfcheader, &mr);
+			if (mr && strlen(mr->value) > 0) {
+				tmp = g_list_join(_imap_get_addresses(mr)," ");
+				g_string_printf(tmp,"(%s)", tmp->str);
+				list = g_list_append(list, g_strdup(tmp->str));
+			} else	/* no from field ??? */
+				list = g_list_append(list, "((NIL NIL \"nobody\" \"nowhere.nirgendwo\"))");
+		} else if (strcasecmp(envelope_items[idx], "sender") == 0) {
+			/* default this field */
+			mime_findfield("from", rfcheader, &mr);
+			if (mr && strlen(mr->value) > 0) {
+				tmp = g_list_join(_imap_get_addresses(mr)," ");
+				g_string_printf(tmp,"(%s)", tmp->str);
+				list = g_list_append(list, g_strdup(tmp->str));
+			} else	/* no from field ??? */
+				list = g_list_append(list, "((NIL NIL \"nobody\" \"nowhere.nirgendwo\"))");
+		} else
+			list = g_list_append(list,"NIL");
+	}
+
+	mime_findfield("in-reply-to", rfcheader, &mr);
+	if (mr && strlen(mr->value) > 0) {
+		list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+	} else
+		list = g_list_append(list, "NIL");
+
+	mime_findfield("message-id", rfcheader, &mr);
+	if (mr && strlen(mr->value) > 0)
+		list = g_list_append(list, dbmail_imap_astring_as_string(mr->value));
+	else
+		list = g_list_append(list, "NIL");
+	g_string_free(tmp,1);
+	return list;
+}
+
+
+/*
+ * _imap_get_addresses()
+ *
+ * gives an address list
+ */
+static GList * _imap_get_addresses(struct mime_record *mr)
+{
+	int delimiter, i, inquote, start, has_split;
+	char savechar;
+	GList * list = NULL;
+	GList * sublist = NULL;
+	GString * tmp = g_string_new("");
+		
+	trace(TRACE_DEBUG,"%s,%s", __FILE__,__func__);
+	
+	/* find ',' to split up multiple addresses */
+	delimiter = 0;
+
+	do {
+		sublist = NULL;
+		start = delimiter;
+
+		for (inquote = 0;
+		     mr->value[delimiter] && !(mr->value[delimiter] == ','
+					       && !inquote); delimiter++)
+			if (mr->value[delimiter] == '\"')
+				inquote ^= 1;
+
+		if (mr->value[delimiter])
+			mr->value[delimiter] = 0;	/* replace ',' by NULL-termination */
+		else
+			delimiter = -1;	/* this will be the last one */
+
+		/* the address currently being processed is now contained within
+		 * &mr->value[start] 'till first '\0'
+		 */
+
+		/* possibilities for the mail address:
+		 * (1) name <user@domain>
+		 * (2) <user@domain>
+		 * (3) user@domain
+		 * scan for '<' to determine which case we should be dealing with;
+		 */
+
+		for (i = start, inquote = 0; mr->value[i] && !(mr->value[i] == '<' && !inquote); i++)
+			if (mr->value[i] == '\"')
+				inquote ^= 1;
+
+		if (mr->value[i]) {
+			if (i > start + 2) {
+				/* name is contained in &mr->value[start] untill &mr->value[i-2] */
+				/* name might contain quotes */
+				savechar = mr->value[i - 1];
+				mr->value[i - 1] = '\0';	/* terminate string */
+				sublist = g_list_append(sublist, dbmail_imap_astring_as_string(&mr->value[start]));
+
+				mr->value[i - 1] = savechar;
+
+			} else
+				sublist = g_list_append(sublist, "NIL");
+
+			start = i + 1;	/* skip to after '<' */
+		} else
+			sublist = g_list_append(sublist, "NIL");
+
+		sublist = g_list_append(sublist, "NIL");	/* source route ?? smtp at-domain-list ?? */
+
+		/*
+		 * now display user domainname; &mr->value[start] is starting point 
+		 */
+		g_string_printf(tmp,"\"");
+		// added a check for whitespace within the address (not good)
+		for (i = start, has_split = 0; mr->value[i] && mr->value[i] != '>' && !isspace(mr->value[i]); i++) {
+			if (mr->value[i] == '@') {
+				tmp = g_string_append(tmp, "\" \"");
+				has_split = 1;
+			} else {
+				if (mr->value[i] == '"')
+					tmp = g_string_append(tmp, "\\");
+				g_string_append_printf(tmp, "%c", mr->value[i]);
+			}
+		}
+
+		if (!has_split)
+			tmp = g_string_append(tmp, "\" \"\"");	/* '@' did not occur */
+		else
+			tmp = g_string_append(tmp, "\"");
+
+		sublist = g_list_append(sublist,strdup(tmp->str));
+		
+		if (delimiter > 0) {
+			mr->value[delimiter++] = ',';	/* restore & prepare for next iteration */
+			while (isspace(mr->value[delimiter]))
+				delimiter++;
+		}
+		tmp = g_list_join(sublist," ");
+		g_string_printf(tmp,"(%s)", tmp->str);
+		list = g_list_append(list, g_strdup(tmp->str));
+
+	} while (delimiter > 0);
+	
+	g_list_foreach(sublist, (GFunc)g_free, NULL);
+	g_list_free(sublist);
+	g_string_free(tmp,1);
+	return list;
+}
+
+
+
+/*
+ * _imap_get_mime_parameters()
+ *
+ * get mime name/value pairs
+ * 
+ * return GList for conversion to plist
+ * 
+ * if force_subtype != 0 'NIL' will be outputted if no subtype is specified
+ * if only_extension != 0 only extension data (after first ';') will be shown
+ */
+static GList * _imap_get_mime_parameters(struct mime_record *mr, int force_subtype, int only_extension)
+{
+	GList * list = NULL;
+	GList * subl = NULL;
+	GString * tmp = g_string_new("");
+	
+	int idx, delimiter, start, end;
+
+	/* find first delimiter */
+	for (delimiter = 0;
+	     mr->value[delimiter] && mr->value[delimiter] != ';';
+	     delimiter++);
+
+	/* are there non-whitespace chars after the delimiter?                    */
+	/* looking for the case where the mime type ends with a ";"               */
+	/* if it is of type "text" it must have a default character set generated */
+	end = strlen(mr->value);
+	for (start = delimiter + 1; (isspace(mr->value[start]) == 0 && start <= end); start++);
+	end = start - delimiter - 1;
+	start = 0;
+	if (end && strstr(mr->value, "text"))
+		start++;
+
+	if (mr->value[delimiter])
+		mr->value[delimiter] = 0;
+	else
+		delimiter = -1;
+
+	if (!only_extension) {
+		/* find main type in value */
+		for (idx = 0; mr->value[idx] && mr->value[idx] != '/';
+		     idx++);
+
+		if (mr->value[idx] && (idx < delimiter || delimiter == -1)) {
+			mr->value[idx] = 0;
+			list = g_list_append(list,dbmail_imap_astring_as_string(mr->value));
+			list = g_list_append(list,dbmail_imap_astring_as_string(&mr->value[idx + 1]));
+
+			mr->value[idx] = '/';
+		} else {
+			list = g_list_append(list,dbmail_imap_astring_as_string(mr->value));
+			list = g_list_append(list, force_subtype ? "NIL" : "");
+		}
+	}
+	if (delimiter >= 0) {
+		/* extra parameters specified */
+		mr->value[delimiter] = ';';
+		idx = delimiter;
+
+		if (start)
+			subl = g_list_append(subl, "\"CHARSET\" \"US-ASCII\"");
+		/* extra params: <name>=<val> [; <name>=<val> [; ...etc...]]
+		 * note that both name and val may or may not be enclosed by 
+		 * either single or double quotation marks
+		 */
+
+		do {
+			/* skip whitespace */
+			for (idx++; isspace(mr->value[idx]); idx++);
+			if (!mr->value[idx])
+				break;	/* ?? */
+
+			/* check if quotation marks are specified */
+			if (mr->value[idx] == '\"' || mr->value[idx] == '\'') {
+				start = ++idx;
+				while (mr->value[idx] && mr->value[idx] != mr->value[start - 1])
+					idx++;
+
+				if (!mr->value[idx] || mr->value[idx + 1] != '=')	/* ?? no end quote */
+					break;
+
+				end = idx;
+				idx += 2;	/* skip to after '=' */
+			} else {
+				start = idx;
+				while (mr->value[idx] && mr->value[idx] != '=')
+					idx++;
+
+				if (!mr->value[idx])	/* ?? no value specified */
+					break;
+
+				end = idx;
+				idx++;	/* skip to after '=' */
+			}
+
+			subl = g_list_append_printf(subl, "\"%.*s\"", (end - start), &mr->value[start]);
+
+			/* now process the value; practically same procedure */
+
+			if (mr->value[idx] == '\"' || mr->value[idx] == '\'') {
+				start = ++idx;
+				while (mr->value[idx] && mr->value[idx] != mr->value[start - 1])
+					idx++;
+
+				if (!mr->value[idx])	/* ?? no end quote */
+					break;
+
+				end = idx;
+				idx++;
+			} else {
+				start = idx;
+
+				while (mr->value[idx] && !isspace(mr->value[idx]) && mr->value[idx] != ';')
+					idx++;
+
+				end = idx;
+			}
+
+			subl = g_list_append_printf(subl, "\"%.*s\"", (end - start), &mr->value[start]);
+
+			/* check for more name/val pairs */
+			while (mr->value[idx] && mr->value[idx] != ';')
+				idx++;
+
+		} while (mr->value[idx]);
+
+		list = g_list_append(list, g_strdup(dbmail_imap_plist_as_string(subl)));
+		g_list_foreach(subl, (GFunc)g_free, NULL);
+		g_list_free(subl);
+		g_string_free(tmp,1);
+	} else {
+		list = g_list_append(list, "NIL");
+	}
+	
+	return list;
+}
+
+
+
+
+static int _imap_session_fetch_parse_partspec(struct ImapSession *self, int idx)
 {
 	/* check for a partspecifier */
 	/* first check if there is a partspecifier (numbers & dots) */
@@ -174,7 +709,7 @@
 	return idx + 1;
 }
 
-static int dbmail_imap_fetch_parse_octet_range(struct ImapSession *self, int idx) 
+static int _imap_session_fetch_parse_octet_range(struct ImapSession *self, int idx) 
 {
 	/* check if octet start/cnt is specified */
 	int delimpos;
@@ -218,14 +753,14 @@
 }
 
 /*
- * dbmail_imap_fetch_parse_args()
+ * dbmail_imap_session_fetch_parse_args()
  *
  * retrieves next item to be fetched from an argument list starting at the given
  * index. The update index is returned being -1 on 'no-more' and -2 on error.
  * arglist is supposed to be formatted according to build_args_array()
  *
  */
-int dbmail_imap_fetch_parse_args(struct ImapSession * self, int idx)
+int dbmail_imap_session_fetch_parse_args(struct ImapSession * self, int idx)
 {
 	int invalidargs, ispeek = 0;
 	
@@ -297,18 +832,18 @@
 					self->fi.getBodyTotalPeek = 1;
 				else
 					self->fi.getBodyTotal = 1;
-				return dbmail_imap_fetch_parse_octet_range(self,idx);
+				return _imap_session_fetch_parse_octet_range(self,idx);
 			}
 			
 			if (ispeek)
 				self->fi.bodyfetch.noseen = 1;
 
 			
-			idx = dbmail_imap_fetch_parse_partspec(self,idx);
+			idx = _imap_session_fetch_parse_partspec(self,idx);
 			if (idx < 0)
 				return -2;
 			idx++;	/* points to ']' now */
-			return dbmail_imap_fetch_parse_octet_range(self,idx);
+			return _imap_session_fetch_parse_octet_range(self,idx);
 		}
 	} else if (MATCH(token,"all")) {		
 		self->fi.msgparse_needed=1;
@@ -345,6 +880,794 @@
 	return idx + 1;
 }
 
+int dbmail_imap_session_fetch_get_unparsed(struct ImapSession *self, u64_t fetch_start, u64_t fetch_end)
+{
+	trace(TRACE_DEBUG, "%s,%s: no parsing at all", __FILE__, __func__ );
+
+	imap_userdata_t *ud = (imap_userdata_t *) self->ci->userData;
+	/* all the info we need can be retrieved by a single
+	 * call to db_get_msginfo_range()
+	 */
+
+	u64_t lo, hi;
+	u64_t i;
+	int j;
+	unsigned nmatching;
+	unsigned fn;
+
+	if (!self->use_uid) {
+		/* find the msgUID's to use */
+		lo = ud->mailbox.seq_list[fetch_start];
+		hi = ud->mailbox.seq_list[fetch_end];
+
+	} else {
+		lo = fetch_start;
+		hi = fetch_end;
+	}
+
+	/* (always retrieve uid) */
+	int result = db_get_msginfo_range(lo, hi, ud->mailbox.uid,
+				 self->fi.getFlags, self->fi.getInternalDate,
+				 self->fi.getSize, 1, &self->msginfo, &nmatching);
+	if (result == -1) {
+		dbmail_imap_session_printf(self, "* BYE internal dbase error\r\n");
+		return -1;
+	}
+
+	if (result == -2) {
+		dbmail_imap_session_printf(self, "* BYE out of memory\r\n");
+		return -1;
+	}
+
+	for (i = 0; i < nmatching; i++) {
+		if (self->fi.getSize && self->msginfo[i].rfcsize == 0) {
+			/* parse the message to calc the size */
+			result = db_fetch_headers(self->msginfo[i].uid, &self->headermsg);
+			if (result == -2) {
+				dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
+				my_free(self->msginfo);
+				return -1;
+			}
+			if (result == -3) {
+				dbmail_imap_session_printf(self, "\r\n* BYE out of memory\r\n");
+				my_free(self->msginfo);
+				return -1;
+			}
+
+			self->msginfo[i].rfcsize = (self->headermsg.rfcheadersize +
+			     self->headermsg.bodysize + self->headermsg.bodylines);
+			db_set_rfcsize(self->msginfo[i].rfcsize, self->msginfo[i].uid, ud->mailbox.uid);
+		}
+
+		if (binary_search (ud->mailbox.seq_list, ud->mailbox.exists, self->msginfo[i].uid, &fn) == -1) {
+			/* this is probably some sync error:
+			 * the msgUID belongs to this mailbox but was not found
+			 * when building the mailbox info
+			 * let's call it fatal and let the client re-connect :)
+			 */
+			dbmail_imap_session_printf(self, "* BYE internal syncing error\r\n");
+			my_free(self->msginfo);
+			return -1;
+		}
+
+		// start building the output
+		GList *list = NULL;
+		GString *string;
+		GString *tmp = g_string_new("");
+		
+		/* fetching results */
+		trace(TRACE_DEBUG, "_ic_fetch(): no parsing, into fetch loop");
+
+		if (self->fi.getInternalDate) {
+			g_string_printf(tmp, "INTERNALDATE \"%s\"",
+					date_sql2imap (self->msginfo[i].internaldate));
+			list = g_list_append(list,g_strdup(tmp->str));
+		}
+
+		if (self->fi.getUID) {
+			g_string_printf(tmp, "UID %llu", self->msginfo[i].uid);
+			list = g_list_append(list,g_strdup(tmp->str));
+		}
+
+		if (self->fi.getSize) {
+			g_string_printf(tmp, "RFC822.SIZE %llu", self->msginfo[i].rfcsize);
+			list = g_list_append(list,g_strdup(tmp->str));
+		}
+
+		if (self->fi.getFlags) {
+
+			GList *sublist = NULL;
+			
+			for (j = 0; j < IMAP_NFLAGS; j++) {
+				if (self->msginfo[i].flags[j]) 
+					sublist = g_list_append(sublist,(gchar *)imap_flag_desc_escaped[j]);
+			}
+			string = g_list_join(sublist," ");
+			
+			g_string_printf(tmp, "FLAGS (%s)", string->str);
+			list = g_list_append(list,g_strdup(tmp->str));
+		}
+
+		string = g_list_join(list," ");
+		dbmail_imap_session_printf(self, "* %u FETCH (%s)\r\n", (fn + 1), string->str);
+	}
+
+	my_free(self->msginfo);
+	return 0;
+}
+
+int dbmail_imap_session_fetch_get_items(struct ImapSession *self)
+{
+	int only_text_from_msgpart = 0;
+	int insert_rfcsize = 0, result;
+	char date[IMAP_INTERNALDATE_LEN];
+	u64_t actual_cnt, tmpdumpsize, rfcsize = 0;
+	int setseen = 0;
+	long long cnt;
+	mime_message_t *msgpart;
+	
+	imap_userdata_t *ud = (imap_userdata_t *) self->ci->userData;
+
+	GList *tlist = NULL;
+	GString *tmp = g_string_new("");
+	
+	/* check RFC822.SIZE request */
+	if (self->fi.getSize) {
+		/* ok, try to fetch size from dbase */
+		if (db_get_rfcsize (self->msg_idnr, ud->mailbox.uid, &rfcsize) == -1) {
+			dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
+			return -1;
+		}
+		if (rfcsize == 0) {
+			/* field is empty in dbase, message needs to be parsed */
+			self->fi.msgparse_needed = 1;
+			insert_rfcsize = 1;
+		}
+	}
+
+
+	/* update cache */
+	if (self->fi.msgparse_needed && self->msg_idnr != cached_msg.num) {
+		if (! self->fi.msgparse_needed) {
+			/* don't update cache if only the main header is needed 
+			 * but do retrieve this main header
+			 */
+
+			result = db_get_main_header(self->msg_idnr, &self->headermsg.rfcheader);
+
+			if (result == -1) {
+				dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
+				return -1;
+			}
+
+			if (result == -2) {
+				dbmail_imap_session_printf(self, "\r\n* BYE out of memory\r\n");
+				return -1;
+			}
+
+		} else {
+			/* parse message structure */
+			if (cached_msg.msg_parsed)
+				db_free_msg(&cached_msg.msg);
+
+			memset(&cached_msg.msg, 0, sizeof(cached_msg.msg));
+
+			cached_msg.msg_parsed = 0;
+			cached_msg.num = -1;
+			cached_msg.file_dumped = 0;
+			mreset(cached_msg.memdump);
+
+			result = db_fetch_headers (self->msg_idnr, &cached_msg.msg);
+			if (result == -2) {
+				dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
+				return -1;
+			}
+			if (result == -3) {
+				dbmail_imap_session_printf(self, "\r\n* BYE out of memory\r\n");
+				return -1;
+			}
+
+			cached_msg.msg_parsed = 1;
+			cached_msg.num = self->msg_idnr;
+
+			rfcsize = (cached_msg.msg.rfcheadersize + cached_msg.msg.bodysize +
+			     cached_msg.msg.bodylines);
+
+			if (insert_rfcsize) {
+				/* insert the rfc822 size into the dbase */
+				if (db_set_rfcsize(rfcsize,self->msg_idnr,ud->mailbox.uid) == -1) {
+					dbmail_imap_session_printf(self,"\r\n* BYE internal dbase error\r\n");
+					return -1;
+				}
+
+				insert_rfcsize = 0;
+			}
+
+		}
+	}
+
+	int isfirstfetchout = 1;
+	int isfirstout = 1;
+	
+	if (self->fi.getInternalDate) {
+		result = db_get_msgdate(ud->mailbox.uid, self->msg_idnr, date);
+		if (result == -1) {
+			dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
+			return -1;
+		}
+
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "INTERNALDATE \"%s\"", date_sql2imap(date));
+	}
+
+	if (self->fi.getUID) {
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "UID %llu", self->msg_idnr);
+	}
+
+	if (self->fi.getMIME_IMB) {
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "BODYSTRUCTURE ");
+		tlist = _imap_get_structure(&cached_msg.msg, 1);
+		if (dbmail_imap_session_printf(self, dbmail_imap_plist_as_string(tlist)) == -1) {
+			dbmail_imap_session_printf(self, "\r\n* BYE error fetching body structure\r\n");
+			return -1;
+		}
+	}
+
+	if (self->fi.getMIME_IMB_noextension) {
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "BODY ");
+		tlist = _imap_get_structure(&cached_msg.msg, 0);
+		if (dbmail_imap_session_printf(self,dbmail_imap_plist_as_string(tlist)) == -1) {
+			dbmail_imap_session_printf(self, "\r\n* BYE error fetching body\r\n");
+			return -1;
+		}
+	}
+
+	if (self->fi.getEnvelope) {
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "ENVELOPE ");
+
+		tlist = _imap_get_envelope(&cached_msg.msg.rfcheader);
+		if (dbmail_imap_session_printf(self, dbmail_imap_plist_as_string(tlist)) == -1) {
+			dbmail_imap_session_printf(self, "\r\n* BYE error fetching envelope structure\r\n");
+			return -1;
+		}
+	}
+
+	if (self->fi.getRFC822 || self->fi.getRFC822Peek) {
+		if (cached_msg.file_dumped == 0 || cached_msg.num != self->msg_idnr) {
+			mreset(cached_msg.memdump);
+
+			cached_msg.dumpsize = rfcheader_dump(cached_msg.memdump,
+			     &cached_msg.msg.rfcheader, self->args, 0, 0);
+
+			cached_msg.dumpsize += db_dump_range(cached_msg.memdump,
+			     cached_msg.msg.bodystart, cached_msg.msg.bodyend, self->msg_idnr);
+
+			cached_msg.file_dumped = 1;
+
+			if (cached_msg.num != self->msg_idnr) {
+				/* if there is a parsed msg in the cache it will be invalid now */
+				if (cached_msg.msg_parsed) {
+					cached_msg.msg_parsed = 0;
+					db_free_msg (&cached_msg.msg);
+				}
+				cached_msg.num = self->msg_idnr;
+			}
+		}
+
+		mseek(cached_msg.memdump, 0, SEEK_SET);
+
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "RFC822 {%llu}\r\n", cached_msg.dumpsize);
+		send_data(self->ci->tx, cached_msg.memdump, cached_msg.dumpsize);
+
+		if (self->fi.getRFC822)
+			setseen = 1;
+
+	}
+
+	if (self->fi.getSize) {
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "RFC822.SIZE %llu", rfcsize);
+	}
+
+	if (self->fi.getBodyTotal || self->fi.getBodyTotalPeek) {
+		if (cached_msg.file_dumped == 0 || cached_msg.num != self->msg_idnr) {
+			cached_msg.dumpsize = rfcheader_dump(cached_msg.memdump,
+			     &cached_msg.msg.rfcheader, self->args, 0, 0);
+
+			cached_msg.dumpsize += db_dump_range(cached_msg.memdump,
+			     cached_msg.msg.bodystart, cached_msg.msg.bodyend, self->msg_idnr);
+
+			if (cached_msg.num != self->msg_idnr) {
+				/* if there is a parsed msg in the cache it will be invalid now */
+				if (cached_msg.msg_parsed) {
+					cached_msg.msg_parsed = 0;
+					db_free_msg(&cached_msg.msg);
+				}
+				cached_msg.num = self->msg_idnr;
+			}
+
+			cached_msg.file_dumped = 1;
+		}
+
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		if (self->fi.bodyfetch.octetstart == -1) {
+			mseek(cached_msg.memdump, 0, SEEK_SET);
+
+			dbmail_imap_session_printf(self, "BODY[] {%llu}\r\n", cached_msg.dumpsize);
+			send_data(self->ci->tx, cached_msg.memdump, cached_msg.dumpsize);
+		} else {
+			mseek(cached_msg.memdump, self->fi.bodyfetch.octetstart, SEEK_SET);
+
+     /** \todo this next statement is ugly because of the
+  casts to 'long long'. Probably, octetcnt should be
+  changed to be a u64_t instead of a long long, because
+  it should never be negative anyway */
+			actual_cnt = (self->fi.bodyfetch.octetcnt >
+			     (((long long)cached_msg.dumpsize) - self->fi.bodyfetch.octetstart))
+			    ? (((long long)cached_msg.dumpsize) - self->fi.bodyfetch.octetstart) 
+			    : self->fi.bodyfetch.octetcnt;
+
+			dbmail_imap_session_printf(self, "BODY[]<%llu> {%llu}\r\n", self->fi.bodyfetch.octetstart, actual_cnt);
+			send_data(self->ci->tx, cached_msg.memdump, actual_cnt);
+		}
+
+		if (self->fi.getBodyTotal)
+			setseen = 1;
+
+	}
+
+	if (self->fi.getRFC822Header) {
+		/* here: msgparse_needed == 1
+		 * if this msg is in cache, retrieve it from there
+		 * otherwise only_main_header_parsing == 1 so retrieve direct
+		 * from the dbase
+		 */
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		if (cached_msg.num == self->msg_idnr) {
+			mrewind(cached_msg.tmpdump);
+			tmpdumpsize = rfcheader_dump(cached_msg.tmpdump, &cached_msg.msg.
+			     rfcheader, self->args, 0, 0);
+
+			mseek(cached_msg.tmpdump, 0, SEEK_SET);
+
+			dbmail_imap_session_printf(self, "RFC822.HEADER {%llu}\r\n", tmpdumpsize);
+			send_data(self->ci->tx, cached_msg.tmpdump, tmpdumpsize);
+		} else {
+			/* remember only_main_header_parsing == 1 here ! */
+
+			/* use cached_msg.tmpdump as temporary storage */
+			mrewind(cached_msg.tmpdump);
+			tmpdumpsize = rfcheader_dump(cached_msg.tmpdump,
+			     &self->headermsg.rfcheader, self->args, 0, 0);
+
+			mseek(cached_msg.tmpdump, 0, SEEK_SET);
+
+			dbmail_imap_session_printf(self, "RFC822.HEADER {%llu}\r\n", tmpdumpsize);
+			send_data(self->ci->tx, cached_msg.tmpdump, tmpdumpsize);
+		}
+	}
+
+	if (self->fi.getRFC822Text) {
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		mrewind(cached_msg.tmpdump);
+		tmpdumpsize = db_dump_range(cached_msg.tmpdump, cached_msg.msg.
+				  bodystart, cached_msg.msg.bodyend, self->msg_idnr);
+
+		mseek(cached_msg.tmpdump, 0, SEEK_SET);
+
+		dbmail_imap_session_printf(self, "RFC822.TEXT {%llu}\r\n", tmpdumpsize);
+		send_data(self->ci->tx, cached_msg.tmpdump, tmpdumpsize);
+
+		setseen = 1;
+	}
+
+	if (self->fi.bodyfetch.itemtype >= 0) {
+		mrewind(cached_msg.tmpdump);
+
+		if (self->fi.bodyfetch.partspec[0]) {
+			if (self->fi.bodyfetch.partspec[0] == '0') {
+				dbmail_imap_session_printf(self, "\r\n%s BAD protocol error\r\n", self->tag);
+				trace(TRACE_DEBUG, "PROTOCOL ERROR");
+				return 1;
+			}
+
+			msgpart = get_part_by_num(&cached_msg.msg, self->fi.bodyfetch.partspec);
+
+			if (!msgpart) {
+				/* if the partspec ends on "1" or "1." the msg body
+				 * of the parent message is to be retrieved
+				 */
+				int partspeclen;
+				partspeclen = strlen(self->fi.bodyfetch.partspec);
+
+				if ((self->fi.bodyfetch.partspec[partspeclen - 1] == '1' && 
+					(partspeclen == 1 || self->fi.bodyfetch.partspec[partspeclen - 2] == '.')
+					)
+				    || ((self->fi.bodyfetch.partspec[partspeclen - 1] == '.'
+				      && self->fi.bodyfetch.partspec[partspeclen - 2] == '1')
+				     && (partspeclen == 2 || self->fi.bodyfetch.partspec[partspeclen - 3] == '.'))
+				    ) {
+					/* ok find the parent of this message */
+					/* start value of k is partspeclen-2 'cause we could
+					   have partspec[partspeclen-1] == '.' right at the start
+					 */
+					int k;
+					for (k = partspeclen - 2; k >= 0; k--)
+						if (self->fi.bodyfetch.partspec[k] == '.')
+							break;
+
+					if (k > 0) {
+						self->fi.bodyfetch.partspec[k] = '\0';
+						msgpart = get_part_by_num(&cached_msg.msg, self->fi.bodyfetch.partspec);
+						self->fi.bodyfetch.partspec[k] = '.';
+					} else
+						msgpart = &cached_msg.msg;
+
+					only_text_from_msgpart = 1;
+				}
+			} else {
+				only_text_from_msgpart = 0;
+			}
+		} else {
+			if (cached_msg.num == self->msg_idnr)
+				msgpart = &cached_msg.msg;
+			else {
+				/* this will be only the case when only_main_header_parsing == 1 */
+				msgpart = &self->headermsg;
+			}
+		}
+
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		if (! self->fi.bodyfetch.noseen)
+			setseen = 1;
+		dbmail_imap_session_printf(self, "BODY[%s", self->fi.bodyfetch.partspec);
+
+		switch (self->fi.bodyfetch.itemtype) {
+		case BFIT_TEXT_SILENT:
+			if (!msgpart)
+				dbmail_imap_session_printf(self, "] NIL ");
+			else {
+				tmpdumpsize = 0;
+
+				if (!only_text_from_msgpart)
+					tmpdumpsize = rfcheader_dump(cached_msg.tmpdump,
+					     &msgpart->rfcheader, self->args, 0, 0);
+
+				tmpdumpsize += db_dump_range(cached_msg.tmpdump,
+				     msgpart->bodystart, msgpart->bodyend, self->msg_idnr);
+
+				if (self->fi.bodyfetch.octetstart >= 0) {
+					cnt = tmpdumpsize - self->fi.bodyfetch.octetstart;
+					if (cnt < 0)
+						cnt = 0;
+					if (cnt > self->fi.bodyfetch.octetcnt)
+						cnt = self->fi.bodyfetch.octetcnt;
+
+					dbmail_imap_session_printf(self, "]<%llu> {%llu}\r\n", self->fi.bodyfetch.octetstart, cnt);
+
+					mseek(cached_msg.tmpdump, self->fi.bodyfetch.octetstart, SEEK_SET);
+				} else {
+					cnt = tmpdumpsize;
+					dbmail_imap_session_printf(self, "] {%llu}\r\n", tmpdumpsize);
+					mseek(cached_msg.tmpdump, 0, SEEK_SET);
+				}
+
+				/* output data */
+				send_data(self->ci->tx, cached_msg.tmpdump, cnt);
+
+			}
+			break;
+
+		case BFIT_TEXT:
+			/* dump body text */
+			dbmail_imap_session_printf(self, "TEXT");
+			if (!msgpart)
+				dbmail_imap_session_printf(self, "] NIL ");
+			else {
+				tmpdumpsize = db_dump_range(cached_msg.tmpdump,
+						msgpart->bodystart, msgpart->bodyend, self->msg_idnr);
+
+				if (self->fi.bodyfetch.octetstart >= 0) {
+					cnt = tmpdumpsize - self->fi.bodyfetch.octetstart;
+					if (cnt < 0)
+						cnt = 0;
+					if (cnt > self->fi.bodyfetch.octetcnt)
+						cnt = self->fi.bodyfetch.octetcnt;
+
+					dbmail_imap_session_printf(self, "]<%llu> {%llu}\r\n", self->fi.bodyfetch.octetstart,cnt);
+
+					mseek(cached_msg.tmpdump, self->fi.bodyfetch.octetstart, SEEK_SET);
+				} else {
+					cnt = tmpdumpsize;
+					dbmail_imap_session_printf(self, "] {%llu}\r\n", tmpdumpsize);
+					mseek(cached_msg.tmpdump, 0, SEEK_SET);
+				}
+				/* output data */
+				send_data(self->ci->tx, cached_msg.tmpdump, cnt);
+			}
+			break;
+
+		case BFIT_HEADER:
+			dbmail_imap_session_printf(self, "HEADER");
+			if (!msgpart || only_text_from_msgpart)
+				dbmail_imap_session_printf(self, "] NIL\r\n");
+			else {
+				tmpdumpsize = rfcheader_dump(cached_msg.tmpdump, 
+						&msgpart->rfcheader, self->args, 0, 0);
+
+				if (!tmpdumpsize) {
+					dbmail_imap_session_printf(self, "] NIL\r\n");
+				} else {
+					if (self->fi.bodyfetch.octetstart >= 0) {
+						cnt = tmpdumpsize - self->fi.bodyfetch.octetstart;
+						if (cnt < 0)
+							cnt = 0;
+						if (cnt > self->fi.bodyfetch.octetcnt)
+							cnt = self->fi.bodyfetch.octetcnt;
+
+						dbmail_imap_session_printf(self, "]<%llu> {%llu}\r\n", self->fi.bodyfetch.octetstart,cnt);
+
+						mseek(cached_msg.tmpdump, self->fi.bodyfetch.octetstart, SEEK_SET);
+					} else {
+						cnt = tmpdumpsize;
+						dbmail_imap_session_printf(self, "] {%llu}\r\n", tmpdumpsize);
+						mseek(cached_msg.tmpdump,0,SEEK_SET);
+					}
+
+					/* output data */
+					send_data(self->ci->tx,cached_msg.tmpdump,cnt);
+
+				}
+			}
+			break;
+			
+		case BFIT_HEADER_FIELDS:
+			dbmail_imap_session_printf(self,"HEADER.FIELDS (");
+
+			isfirstout = 1;
+			int k;
+			for (k = 0; k < self->fi.bodyfetch.argcnt; k++) {
+				if (isfirstout)
+					isfirstout = 0;
+				else
+					dbmail_imap_session_printf(self, " ");
+				
+				dbmail_imap_session_printf(self, "%s", self->args[k + self->fi.bodyfetch.argstart]);
+			}
+
+			dbmail_imap_session_printf(self, ")] ");
+
+			if (!msgpart || only_text_from_msgpart)
+				dbmail_imap_session_printf(self, "NIL\r\n");
+			else {
+				tmpdumpsize = rfcheader_dump(cached_msg.tmpdump, 
+						&msgpart->rfcheader, &self->args[self->fi.bodyfetch.argstart], 
+						self->fi.bodyfetch.argcnt, 1);
+
+				if (!tmpdumpsize) {
+					dbmail_imap_session_printf(self, "NIL\r\n");
+				} else {
+					if (self->fi.bodyfetch.octetstart >= 0) {
+						cnt = tmpdumpsize - self->fi.bodyfetch.octetstart;
+						if (cnt < 0)
+							cnt = 0;
+						if (cnt > self->fi.bodyfetch.octetcnt)
+							cnt = self->fi.bodyfetch.octetcnt;
+
+						dbmail_imap_session_printf(self, "<%llu> {%llu}\r\n", self->fi.bodyfetch.octetstart, cnt);
+
+						mseek(cached_msg.tmpdump, self->fi.bodyfetch.octetstart, SEEK_SET);
+					} else {
+						cnt = tmpdumpsize;
+						dbmail_imap_session_printf(self, "{%llu}\r\n", tmpdumpsize);
+						mseek(cached_msg.tmpdump, 0, SEEK_SET);
+					}
+
+					/* output data */
+					send_data(self->ci->tx,cached_msg.tmpdump,cnt);
+
+				}
+			}
+			break;
+		case BFIT_HEADER_FIELDS_NOT:
+			dbmail_imap_session_printf(self, "HEADER.FIELDS.NOT (");
+
+			isfirstout = 1;
+			for (k = 0; k < self->fi.bodyfetch.argcnt; k++) {
+				if (isfirstout)
+					isfirstout = 0;
+				else
+					dbmail_imap_session_printf(self, " ");
+				
+				dbmail_imap_session_printf(self, "%s", self->args[k + self->fi.bodyfetch.argstart]);
+			}
+
+			dbmail_imap_session_printf(self, ")] ");
+
+			if (!msgpart || only_text_from_msgpart)
+				dbmail_imap_session_printf(self, "NIL\r\n");
+			else {
+				tmpdumpsize = rfcheader_dump(cached_msg.tmpdump, 
+						&msgpart->rfcheader, &self->args[self->fi.bodyfetch.argstart],
+						self->fi.bodyfetch.argcnt, 0);
+
+				if (!tmpdumpsize) {
+					dbmail_imap_session_printf(self, "NIL\r\n");
+				} else {
+					if (self->fi.bodyfetch.octetstart >= 0) {
+						cnt = tmpdumpsize - self->fi.bodyfetch.octetstart;
+						if (cnt < 0)
+							cnt = 0;
+						if (cnt > self->fi.bodyfetch.octetcnt)
+							cnt = self->fi.bodyfetch.octetcnt;
+
+						dbmail_imap_session_printf(self, "<%llu> {%llu}\r\n", self->fi.bodyfetch.octetstart, cnt);
+
+						mseek(cached_msg.tmpdump, self->fi.bodyfetch.octetstart, SEEK_SET);
+					} else {
+						cnt = tmpdumpsize;
+						dbmail_imap_session_printf(self, "{%llu}\r\n", tmpdumpsize);
+						mseek(cached_msg.tmpdump, 0, SEEK_SET);
+					}
+
+					/* output data */
+					send_data(self->ci->tx, cached_msg.tmpdump, cnt);
+				}
+			}
+			break;
+		case BFIT_MIME:
+			dbmail_imap_session_printf(self, "MIME] ");
+
+			if (!msgpart)
+				dbmail_imap_session_printf(self, "NIL\r\n");
+			else {
+				tmpdumpsize = mimeheader_dump(cached_msg.tmpdump, &msgpart->mimeheader);
+
+				if (!tmpdumpsize) {
+					dbmail_imap_session_printf(self, "NIL\r\n");
+				} else {
+					if (self->fi.bodyfetch.octetstart >= 0) {
+						cnt = tmpdumpsize - self->fi.bodyfetch.octetstart;
+						if (cnt < 0)
+							cnt = 0;
+						if (cnt > self->fi.bodyfetch.octetcnt)
+							cnt = self->fi.bodyfetch.octetcnt;
+
+						dbmail_imap_session_printf(self, "<%llu> {%llu}\r\n", self->fi.bodyfetch.octetstart, cnt);
+
+						mseek(cached_msg.tmpdump, self->fi.bodyfetch.octetstart, SEEK_SET);
+					} else {
+						cnt = tmpdumpsize;
+						dbmail_imap_session_printf(self, "{%llu}\r\n", tmpdumpsize);
+						mseek(cached_msg.tmpdump, 0, SEEK_SET);
+					}
+
+					/* output data */
+					send_data(self->ci->tx, cached_msg.tmpdump, cnt);
+				}
+			}
+
+			break;
+		default:
+			dbmail_imap_session_printf(self, "\r\n* BYE internal server error\r\n");
+			return -1;
+		}
+	}
+
+
+	/* set \Seen flag if necessary; note the absence of an error-check 
+	 * for db_get_msgflag()!
+	 */
+	int setSeenSet[IMAP_NFLAGS] = { 1, 0, 0, 0, 0, 0 };
+	if (setseen && db_get_msgflag("seen", self->msg_idnr, ud->mailbox.uid) != 1) {
+		/* only if the user has an ACL which grants
+		   him rights to set the flag should the
+		   flag be set! */
+		result = acl_has_right(ud->userid, ud->mailbox.uid, ACL_RIGHT_SEEN);
+		if (result == -1) {
+			dbmail_imap_session_printf(self, "\r\n *BYE internal dbase error\r\n");
+			return -1;
+		}
+		
+		if (result == 1) {
+			result = db_set_msgflag(self->msg_idnr, ud->mailbox.uid, setSeenSet, IMAPFA_ADD);
+			if (result == -1) {
+				dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
+				return -1;
+			}
+		}
+
+		self->fi.getFlags = 1;
+		dbmail_imap_session_printf(self, " ");
+	}
+
+	/* FLAGS ? */
+	if (self->fi.getFlags) {
+		if (isfirstfetchout)
+			isfirstfetchout = 0;
+		else
+			dbmail_imap_session_printf(self, " ");
+
+		dbmail_imap_session_printf(self, "FLAGS (");
+
+		isfirstout = 1;
+
+		int msgflags[IMAP_NFLAGS];
+		result = db_get_msgflag_all(self->msg_idnr, ud->mailbox.uid, msgflags);
+		if (result == -1) {
+			dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
+			return -1;
+		}
+		int j;	
+		for (j = 0; j < IMAP_NFLAGS; j++) {
+			if (msgflags[j]) {
+				if (isfirstout)
+					isfirstout = 0;
+				else
+					dbmail_imap_session_printf(self, " ");
+				dbmail_imap_session_printf(self, "\\%s", imap_flag_desc[j]);
+			}
+		}
+		dbmail_imap_session_printf(self, ")");
+	}
+	dbmail_imap_session_printf(self, ")\r\n");
+
+	g_string_free(tmp,1);
+	g_list_foreach(tlist, (GFunc)g_free, NULL);
+	g_list_free(tlist);
+
+	return 0;
+}
+
 
 /*
  * check_state_and_args()
diff -urNad /usr/src/dbmail2/dbmail-2.1/dbmail-imapsession.h dbmail-2.1/dbmail-imapsession.h
--- /usr/src/dbmail2/dbmail-2.1/dbmail-imapsession.h	2004-10-21 11:53:09.000000000 +0200
+++ dbmail-2.1/dbmail-imapsession.h	2004-10-21 15:50:38.000000000 +0200
@@ -20,6 +20,7 @@
 	char **args;
 	fetch_items_t fi;
 	struct DbmailMessage *message;
+	mime_message_t headermsg;
 	msginfo_t *msginfo;
 };
 
@@ -50,5 +51,10 @@
 int dbmail_imap_session_mailbox_show_info(struct ImapSession * self);
 int dbmail_imap_session_mailbox_open(struct ImapSession * self, char * mailbox);
 
+
+int dbmail_imap_session_fetch_parse_args(struct ImapSession * self, int idx);
+int dbmail_imap_session_fetch_get_unparsed(struct ImapSession *self, u64_t fetch_start, u64_t fetch_end);
+int dbmail_imap_session_fetch_get_items(struct ImapSession *self);
+
 #endif
 
diff -urNad /usr/src/dbmail2/dbmail-2.1/imap4.c dbmail-2.1/imap4.c
--- /usr/src/dbmail2/dbmail-2.1/imap4.c	2004-10-21 11:57:23.000000000 +0200
+++ dbmail-2.1/imap4.c	2004-10-21 15:50:38.000000000 +0200
@@ -35,6 +35,7 @@
 #include "imap4.h"
 #include "imaputil.h"
 #include "imapcommands.h"
+#include "dbmail-imapsession.h"
 #include "misc.h"
 #include "clientinfo.h"
 #include "debug.h"
@@ -50,18 +51,6 @@
 /* cache */
 cache_t cached_msg;
 
-/* consts */
-const char AcceptedChars[] =
-    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
-    "!@#$%^&*()-=_+`~[]{}\\|'\" ;:,.<>/? \n\r";
-
-const char AcceptedTagChars[] =
-    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
-    "!@#$%^&-=_`~\\|'\" ;:,.<>/? ";
-
-const char AcceptedMailboxnameChars[] =
-    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-=/ _.&,+";
-
 const char *IMAP_COMMANDS[] = {
 	"", "capability", "noop", "logout",
 	"authenticate", "login",
diff -urNad /usr/src/dbmail2/dbmail-2.1/imapcommands.c dbmail-2.1/imapcommands.c
--- /usr/src/dbmail2/dbmail-2.1/imapcommands.c	2004-10-21 11:57:23.000000000 +0200
+++ dbmail-2.1/imapcommands.c	2004-10-21 15:50:38.000000000 +0200
@@ -2192,142 +2192,40 @@
 	imap_userdata_t *ud = (imap_userdata_t *) self->ci->userData;
 	u64_t i, fetch_start, fetch_end;
 	unsigned fn;
-	int result, setseen, idx, j, k;
-	int only_main_header_parsing = 1, insert_rfcsize;
-	int isfirstout, isfirstfetchout, uid_will_be_fetched;
-	int partspeclen, only_text_from_msgpart = 0;
-	int bad_response_send = 0;
-	u64_t actual_cnt;
-	fetch_items_t *fi, fetchitem;
-	mime_message_t *msgpart;
-	char date[IMAP_INTERNALDATE_LEN], *endptr;
-	u64_t thisnum;
-	u64_t tmpdumpsize, rfcsize = 0;
-	long long cnt;
-	int msgflags[IMAP_NFLAGS];
-	struct list fetch_list;
-	mime_message_t headermsg;	/* for main-header & rfcsize parsing */
-	struct element *curr;
-	int setSeenSet[IMAP_NFLAGS] = { 1, 0, 0, 0, 0, 0 };
-	msginfo_t *msginfo;
-	u64_t lo, hi;
-	unsigned nmatching;
-	int no_parsing_at_all = 1, getrfcsize = 0, getinternaldate =
-	    0, getflags = 0;
+	int result, idx;
+	int insert_rfcsize;
+	char *endptr;
 	char *lastchar = NULL;
-	memset(&fetch_list, 0, sizeof(fetch_list));
-	memset(&headermsg, 0, sizeof(headermsg));
 
-	if (ud->state != IMAPCS_SELECTED) {
-		dbmail_imap_session_printf(self,
-			"%s BAD FETCH command received in invalid state\r\n",
-			self->tag);
-		return 1;
-	}
-
-	if (!self->args[0] || !self->args[1]) {
-		dbmail_imap_session_printf(self, "%s BAD missing argument(s) to FETCH\r\n",
-			self->tag);
+	if (!check_state_and_args (self, "FETCH", 2, 0, IMAPCS_SELECTED))
 		return 1;
-	}
 
 	/* check if the user has the right to fetch messages in this mailbox */
-	result =
-	    acl_has_right(ud->userid, ud->mailbox.uid, ACL_RIGHT_READ);
+	result = acl_has_right(ud->userid, ud->mailbox.uid, ACL_RIGHT_READ);
 	if (result < 0) {
 		dbmail_imap_session_printf(self, "* BYE internal database error\r\n");
 		return -1;
 	}
 	if (result == 0) {
-		dbmail_imap_session_printf(self,
-			"%s NO no permission to fetch from mailbox\r\n",
-			self->tag);
+		dbmail_imap_session_printf(self, "%s NO no permission to fetch from mailbox\r\n", self->tag);
 		return 1;
 	}
+	
+	dbmail_imap_session_resetFi(self);
+
+	self->fi.getUID = self->use_uid;
 
-	/* fetch fetch items */
-	list_init(&fetch_list);
 	idx = 1;
-	uid_will_be_fetched = 0;
 	do {
-		idx = next_fetch_item(self->args, idx, &fetchitem);
+		idx = dbmail_imap_session_fetch_parse_args(self, idx);
 		if (idx == -2) {
-			list_freelist(&fetch_list.start);
-			dbmail_imap_session_printf(self,
-				"%s BAD invalid argument list to fetch\r\n",
-				self->tag);
-			return 1;
-		}
-
-		if (idx > 0
-		    && !list_nodeadd(&fetch_list, &fetchitem,
-				     sizeof(fetchitem))) {
-			list_freelist(&fetch_list.start);
-			dbmail_imap_session_printf(self, "* BYE out of memory\r\n");
+			dbmail_imap_session_printf(self, "%s BAD invalid argument list to fetch\r\n", self->tag);
 			return 1;
 		}
-
-		if (fetchitem.msgparse_needed) {
-			no_parsing_at_all = 0;
-		} else if (no_parsing_at_all) {
-			if (fetchitem.getFlags)
-				getflags = 1;
-			if (fetchitem.getSize)
-				getrfcsize = 1;
-			if (fetchitem.getInternalDate)
-				getinternaldate = 1;
-			/* the msgUID will be retrieved anyway so if it is requested, it will be fetched */
-		}
-
-		if (fetchitem.msgparse_needed && only_main_header_parsing) {
-			/* check to see wether all the information can be retrieved from the
-			 * main message header (not the entire message has to be parsed then)
-			 *
-			 * this is the case when:
-			 * FETCH RFC822.HEADER
-			 *       BODY[HEADER]
-			 *       BODY[HEADER.FIELDS ]
-			 *       BODY[HEADER.FIELDS.NOT ]
-			 *       BODY.PEEK[HEADER]
-			 *       BODY.PEEK[HEADER.FIELDS ]
-			 *       BODY.PEEK[HEADER.FIELDS.NOT ]
-			 *
-			 */
-
-			if (!(fetchitem.getRFC822Header ||
-			      ((fetchitem.bodyfetch.itemtype == BFIT_HEADER
-				|| fetchitem.bodyfetch.itemtype ==
-				BFIT_HEADER_FIELDS
-				|| fetchitem.bodyfetch.itemtype ==
-				BFIT_HEADER_FIELDS_NOT)
-			       && fetchitem.bodyfetch.partspec[0] == 0)
-			    )
-			    ) {
-				only_main_header_parsing = 0;
-			}
-		}
-
-		if (fetchitem.getUID)
-			uid_will_be_fetched = 1;
-
 	} while (idx > 0);
 
-	if (!uid_will_be_fetched && imapcommands_use_uid) {
-		/* make sure UID will be on the fetch-item list */
-		memset(&fetchitem, 0, sizeof(fetchitem));
-		fetchitem.getUID = 1;
-		fetchitem.bodyfetch.itemtype = -1;
-
-		if (!list_nodeadd
-		    (&fetch_list, &fetchitem, sizeof(fetchitem))) {
-			list_freelist(&fetch_list.start);
-			dbmail_imap_session_printf(self, "* BYE out of memory\r\n");
-			return -1;
-		}
-	}
-
-	fetch_list.start = dbmail_list_reverse(fetch_list.start);
-
+	trace(TRACE_DEBUG,"%s,%s: hdrparse_needed [%d]", __FILE__,__func__, self->fi.hdrparse_needed);
+	trace(TRACE_DEBUG,"%s,%s: msgparse_needed [%d]", __FILE__,__func__, self->fi.msgparse_needed);
 	/* now fetch results for each msg */
 	endptr = self->args[0];
 	while (*endptr) {
@@ -2336,19 +2234,13 @@
 
 		fetch_start = strtoull(endptr, &endptr, 10);
 
-		if (fetch_start == 0 || fetch_start >
-		    (imapcommands_use_uid ? (ud->mailbox.msguidnext - 1) :
-		     ud->mailbox.exists)) {
-			if (imapcommands_use_uid)
-				dbmail_imap_session_printf(self,
-					"%s OK FETCH completed\r\n", self->tag);
+		if (fetch_start == 0 || fetch_start > (self->use_uid ? (ud->mailbox.msguidnext - 1) : ud->mailbox.exists)) {
+			if (self->fi.getUID)
+				dbmail_imap_session_printf(self, "%s OK FETCH completed\r\n", self->tag);
 			else
-				dbmail_imap_session_printf(self,
-					"%s BAD invalid message range specified\r\n",
-					self->tag);
+				dbmail_imap_session_printf(self, "%s BAD invalid message range specified\r\n", self->tag);
 
-			list_freelist(&fetch_list.start);
-			return !imapcommands_use_uid;
+			return !self->fi.getUID;
 		}
 
 		switch (*endptr) {
@@ -2357,23 +2249,14 @@
 			endptr = lastchar;
 
 			if (*endptr == '*') {
-				fetch_end = (imapcommands_use_uid ?
-					     (ud->mailbox.msguidnext -
-					      1) : ud->mailbox.exists);
+				fetch_end = (self->use_uid ?  (ud->mailbox.msguidnext - 1) : ud->mailbox.exists);
 				endptr++;
 				break;
 			}
 
-			if (fetch_end == 0 || fetch_end >
-			    (imapcommands_use_uid
-			     ? (ud->mailbox.msguidnext -
-				1) : ud->mailbox.exists)) {
-				if (!imapcommands_use_uid) {
-					dbmail_imap_session_printf(self,
-						"%s BAD invalid message range specified\r\n",
-						self->tag);
-
-					list_freelist(&fetch_list.start);
+			if (fetch_end == 0 || fetch_end > (self->use_uid ? (ud->mailbox.msguidnext - 1) : ud->mailbox.exists)) {
+				if (!self->fi.getUID) {
+					dbmail_imap_session_printf(self, "%s BAD invalid message range specified\r\n", self->tag);
 					return 1;
 				}
 			}
@@ -2391,224 +2274,36 @@
 			break;
 
 		default:
-			dbmail_imap_session_printf(self,
-				"%s BAD invalid character in message range\r\n",
-				self->tag);
-			list_freelist(&fetch_list.start);
+			dbmail_imap_session_printf(self, "%s BAD invalid character in message range\r\n", self->tag);
 			return 1;
 		}
 
-		if (!imapcommands_use_uid) {
+		
+		if (! self->use_uid) {
 			fetch_start--;
 			fetch_end--;
 		}
 
-		if (no_parsing_at_all) {
-			trace(TRACE_DEBUG,
-			      "ic_fetch(): no parsing at all");
-
-			/* all the info we need can be retrieved by a single
-			 * call to db_get_msginfo_range()
-			 */
-			if (!imapcommands_use_uid) {
-				/* find the msgUID's to use */
-				lo = ud->mailbox.seq_list[fetch_start];
-				hi = ud->mailbox.seq_list[fetch_end];
-
-			} else {
-				lo = fetch_start;
-				hi = fetch_end;
-			}
-
-			/* (always retrieve uid) */
-			result =
-			    db_get_msginfo_range(lo, hi, ud->mailbox.uid,
-						 getflags, getinternaldate,
-						 getrfcsize, 1, &msginfo,
-						 &nmatching);
-
-			if (result == -1) {
-				list_freelist(&fetch_list.start);
-				dbmail_imap_session_printf(self,
-					"* BYE internal dbase error\r\n");
-				return -1;
-			}
-
-			if (result == -2) {
-				list_freelist(&fetch_list.start);
-				dbmail_imap_session_printf(self, "* BYE out of memory\r\n");
+		
+		if (! (self->fi.msgparse_needed || self->fi.hdrparse_needed)) {
+			if (dbmail_imap_session_fetch_get_unparsed(self, fetch_start, fetch_end) < 0)
 				return -1;
-			}
-
-			for (i = 0; i < nmatching; i++) {
-				if (getrfcsize && msginfo[i].rfcsize == 0) {
-					/* parse the message to calc the size */
-					result =
-					    db_fetch_headers(msginfo[i].
-							     uid,
-							     &headermsg);
-					if (result == -2) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE internal dbase error\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						my_free(msginfo);
-						return -1;
-					}
-					if (result == -3) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE out of memory\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						my_free(msginfo);
-						return -1;
-					}
-
-					msginfo[i].rfcsize =
-					    (headermsg.rfcheadersize +
-					     headermsg.bodysize +
-					     headermsg.bodylines);
-
-					db_set_rfcsize(msginfo[i].rfcsize,
-						       msginfo[i].uid,
-						       ud->mailbox.uid);
-					db_free_msg(&headermsg);
-				}
-
-				if (binary_search
-				    (ud->mailbox.seq_list,
-				     ud->mailbox.exists, msginfo[i].uid,
-				     &fn) == -1) {
-					/* this is probably some sync error:
-					 * the msgUID belongs to this mailbox but was not found
-					 * when building the mailbox info
-					 * let's call it fatal and let the client re-connect :)
-					 */
-					dbmail_imap_session_printf(self,
-						"* BYE internal syncing error\r\n");
-
-					list_freelist(&fetch_list.start);
-					my_free(msginfo);
-					return -1;
-				}
-
-				dbmail_imap_session_printf(self, "* %u FETCH (", (fn + 1));
-
-				curr = list_getstart(&fetch_list);
-				isfirstfetchout = 1;
-
-				while (curr) {
-					trace(TRACE_DEBUG,
-					      "_ic_fetch(): no parsing, into fetch loop");
-
-					fi = (fetch_items_t *) curr->data;
-
-					if (fi->getInternalDate) {
-						if (isfirstfetchout)
-							isfirstfetchout =
-							    0;
-						else
-							dbmail_imap_session_printf(self,
-								" ");
-
-						dbmail_imap_session_printf(self,
-							"INTERNALDATE \"%s\"",
-							date_sql2imap
-							(msginfo[i].
-							 internaldate));
-					}
-
-					if (fi->getUID) {
-						if (isfirstfetchout)
-							isfirstfetchout =
-							    0;
-						else
-							dbmail_imap_session_printf(self,
-								" ");
-
-						dbmail_imap_session_printf(self, "UID %llu",
-							msginfo[i].uid);
-					}
-
-					if (fi->getSize) {
-						if (isfirstfetchout)
-							isfirstfetchout =
-							    0;
-						else
-							dbmail_imap_session_printf(self,
-								" ");
-
-						dbmail_imap_session_printf(self,
-							"RFC822.SIZE %llu",
-							msginfo[i].
-							rfcsize);
-					}
-
-					if (fi->getFlags) {
-						isfirstout = 1;
-
-						if (isfirstfetchout)
-							isfirstfetchout =
-							    0;
-						else
-							dbmail_imap_session_printf(self,
-								" ");
-
-						dbmail_imap_session_printf(self, "FLAGS (");
-						for (j = 0;
-						     j < IMAP_NFLAGS;
-						     j++) {
-							if (msginfo[i].
-							    flags[j]) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "%s%s",
-								     isfirstout
-								     ? "" :
-								     " ",
-								     imap_flag_desc_escaped
-								     [j]);
-								if (isfirstout)
-									isfirstout
-									    =
-									    0;
-							}
-						}
-						dbmail_imap_session_printf(self, ")");
-					}
-
-					curr = curr->nextnode;
-				}
-
-				dbmail_imap_session_printf(self, ")\r\n");
-			}
-
-			my_free(msginfo);
 		}
 
 		/* if there is no parsing at all, this loop is not needed */
-		for (i = fetch_start; i <= fetch_end && !no_parsing_at_all;
-		     i++) {
-			thisnum =
-			    (imapcommands_use_uid ? i : ud->mailbox.
-			     seq_list[i]);
+		for (i = fetch_start; i <= fetch_end; i++) {
+			self->msg_idnr = (self->use_uid ? i : ud->mailbox.seq_list[i]);
 			insert_rfcsize = 0;
 
-			if (imapcommands_use_uid) {
+			if (self->use_uid) {
 				if (i > ud->mailbox.msguidnext - 1) {
 					/* passed the last one */
-					dbmail_imap_session_printf(self,
-						"%s OK FETCH completed\r\n",
-						self->tag);
-					list_freelist(&fetch_list.start);
+					dbmail_imap_session_printf(self, "%s OK FETCH completed\r\n", self->tag);
 					return 0;
 				}
 
 				/* check if the message with this UID belongs to this mailbox */
-				if (binary_search
-				    (ud->mailbox.seq_list,
-				     ud->mailbox.exists, i, &fn) == -1) {
+				if (binary_search (ud->mailbox.seq_list, ud->mailbox.exists, i, &fn) == -1) {
 					continue;
 				}
 
@@ -2617,1242 +2312,21 @@
 			} else
 				dbmail_imap_session_printf(self, "* %llu FETCH (", i + 1);
 
-			trace(TRACE_DEBUG,
-			      "Fetching msgID %llu (fetch num %llu)",
-			      thisnum, i + 1);
-
-			curr = list_getstart(&fetch_list);
-			setseen = 0;
-			bad_response_send = 0;
-
-			isfirstfetchout = 1;
-
-			while (curr && !bad_response_send) {
-				fi = (fetch_items_t *) curr->data;
-				fflush(self->ci->tx);
-
-				only_text_from_msgpart = 0;
-
-				/* check RFC822.SIZE request */
-				if (fi->getSize) {
-					/* ok, try to fetch size from dbase */
-					if (db_get_rfcsize
-					    (thisnum, ud->mailbox.uid,
-					     &rfcsize) == -1) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE internal dbase error\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						return -1;
-					}
-
-					if (rfcsize == 0) {
-						/* field is empty in dbase, message needs 
-						   to be parsed */
-						fi->msgparse_needed = 1;
-						only_main_header_parsing =
-						    0;
-						insert_rfcsize = 1;
-					}
-				}
-
-
-				/* update cache */
-				if (fi->msgparse_needed
-				    && thisnum != cached_msg.num) {
-					if (only_main_header_parsing) {
-						/* don't update cache if only the main header is needed 
-						 * but do retrieve this main header
-						 */
-
-						result = db_get_main_header(thisnum, &headermsg.rfcheader);
-
-						if (result == -1) {
-							dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
-							list_freelist(&fetch_list.start);
-							db_free_msg(&headermsg);
-							return -1;
-						}
-
-						if (result == -2) {
-							dbmail_imap_session_printf(self, "\r\n* BYE out of memory\r\n");
-							list_freelist(&fetch_list.start);
-							db_free_msg(&headermsg);
-							return -1;
-						}
-
-					} else {
-						/* parse message structure */
-						if (cached_msg.msg_parsed)
-							db_free_msg(&cached_msg.msg);
-
-						memset(&cached_msg.msg, 0, sizeof(cached_msg.msg));
-
-						cached_msg.msg_parsed = 0;
-						cached_msg.num = -1;
-						cached_msg.file_dumped = 0;
-						mreset(cached_msg.memdump);
-
-						result = db_fetch_headers(thisnum, &cached_msg.msg);
-						if (result == -2) {
-							dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
-							list_freelist (&fetch_list.  start);
-							db_free_msg (&headermsg);
-							return -1;
-						}
-						if (result == -3) {
-							dbmail_imap_session_printf(self, "\r\n* BYE out of memory\r\n");
-							list_freelist (&fetch_list.start);
-							db_free_msg (&headermsg);
-							return -1;
-						}
-
-						cached_msg.msg_parsed = 1;
-						cached_msg.num = thisnum;
-
-						rfcsize = (cached_msg.msg.rfcheadersize + cached_msg.msg.bodysize + cached_msg.msg.bodylines);
-
-						if (insert_rfcsize) {
-							/* insert the rfc822 size into the dbase */
-							if (db_set_rfcsize
-							    (rfcsize,
-							     thisnum,
-							     ud->mailbox.
-							     uid) == -1) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "\r\n* BYE internal dbase error\r\n");
-								list_freelist
-								    (&fetch_list.
-								     start);
-								db_free_msg
-								    (&headermsg);
-								return -1;
-							}
-
-							insert_rfcsize = 0;
-						}
-
-					}
-				}
-
-				if (fi->getInternalDate) {
-					result =
-					    db_get_msgdate(ud->mailbox.uid,
-							   thisnum, date);
-					if (result == -1) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE internal dbase error\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						db_free_msg(&headermsg);
-						return -1;
-					}
-
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self,
-						"INTERNALDATE \"%s\"",
-						date_sql2imap(date));
-				}
-
-				if (fi->getUID) {
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self, "UID %llu",
-						thisnum);
-				}
-
-				if (fi->getMIME_IMB) {
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self, "BODYSTRUCTURE ");
-					result =
-					    retrieve_structure(self->ci->tx,
-							       &cached_msg.
-							       msg, 1);
-					if (result == -1) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE error fetching body structure\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						db_free_msg(&headermsg);
-						return -1;
-					}
-				}
-
-				if (fi->getMIME_IMB_noextension) {
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self, "BODY ");
-					result =
-					    retrieve_structure(self->ci->tx,
-							       &cached_msg.
-							       msg, 0);
-					if (result == -1) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE error fetching body\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						db_free_msg(&headermsg);
-						return -1;
-					}
-				}
-
-				if (fi->getEnvelope) {
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self, "ENVELOPE ");
-					result =
-					    retrieve_envelope(self->ci->tx,
-							      &cached_msg.
-							      msg.
-							      rfcheader);
-
-					if (result == -1) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE error fetching envelope structure\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						db_free_msg(&headermsg);
-						return -1;
-					}
-				}
-
-				if (fi->getRFC822 || fi->getRFC822Peek) {
-					if (cached_msg.file_dumped == 0
-					    || cached_msg.num != thisnum) {
-						mreset(cached_msg.memdump);
-
-						cached_msg.dumpsize =
-						    rfcheader_dump
-						    (cached_msg.memdump,
-						     &cached_msg.msg.rfcheader, self->args, 0,
-						     0);
-
-						cached_msg.dumpsize +=
-						    db_dump_range(cached_msg.memdump, 
-								    cached_msg.msg.bodystart, 
-								    cached_msg.msg.bodyend, 
-								    thisnum);
-
-						cached_msg.file_dumped = 1;
-
-						if (cached_msg.num !=
-						    thisnum) {
-							/* if there is a parsed msg in the cache it will be invalid now */
-							if (cached_msg.
-							    msg_parsed) {
-								cached_msg.
-								    msg_parsed
-								    = 0;
-								db_free_msg
-								    (&cached_msg.
-								     msg);
-							}
-							cached_msg.num =
-							    thisnum;
-						}
-					}
-
-					mseek(cached_msg.memdump, 0,
-					      SEEK_SET);
-
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self,
-						"RFC822 {%llu}\r\n",
-						cached_msg.dumpsize);
-					send_data(self->ci->tx,
-						  cached_msg.memdump,
-						  cached_msg.dumpsize);
-
-					if (fi->getRFC822)
-						setseen = 1;
-
-				}
-
-				if (fi->getSize) {
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self, "RFC822.SIZE %llu",
-						rfcsize);
-				}
-
-				if (fi->getBodyTotal
-				    || fi->getBodyTotalPeek) {
-					if (cached_msg.file_dumped == 0
-					    || cached_msg.num != thisnum) {
-						cached_msg.dumpsize =
-						    rfcheader_dump
-						    (cached_msg.memdump,
-						     &cached_msg.msg.
-						     rfcheader, self->args, 0,
-						     0);
-
-						cached_msg.dumpsize +=
-						    db_dump_range
-						    (cached_msg.memdump,
-						     cached_msg.msg.
-						     bodystart,
-						     cached_msg.msg.
-						     bodyend, thisnum);
-
-
-						if (cached_msg.num !=
-						    thisnum) {
-							/* if there is a parsed msg in the cache it will be invalid now */
-							if (cached_msg.
-							    msg_parsed) {
-								cached_msg.
-								    msg_parsed
-								    = 0;
-								db_free_msg
-								    (&cached_msg.
-								     msg);
-							}
-							cached_msg.num =
-							    thisnum;
-						}
-
-						cached_msg.file_dumped = 1;
-					}
-
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					if (fi->bodyfetch.octetstart == -1) {
-						mseek(cached_msg.memdump,
-						      0, SEEK_SET);
-
-						dbmail_imap_session_printf(self,
-							"BODY[] {%llu}\r\n",
-							cached_msg.
-							dumpsize);
-						send_data(self->ci->tx,
-							  cached_msg.
-							  memdump,
-							  cached_msg.
-							  dumpsize);
-					} else {
-						mseek(cached_msg.memdump,
-						      fi->bodyfetch.
-						      octetstart,
-						      SEEK_SET);
-
-		      /** \todo this next statement is ugly because of the
-			  casts to 'long long'. Probably, octetcnt should be
-			  changed to be a u64_t instead of a long long, because
-			  it should never be negative anyway */
-						actual_cnt =
-						    (fi->bodyfetch.
-						     octetcnt >
-						     (((long long)
-						       cached_msg.
-						       dumpsize) -
-						      fi->bodyfetch.
-						      octetstart))
-						    ? (((long long)
-							cached_msg.
-							dumpsize)
-						       -
-						       fi->bodyfetch.
-						       octetstart) : fi->
-						    bodyfetch.octetcnt;
-
-						dbmail_imap_session_printf(self,
-							"BODY[]<%llu> {%llu}\r\n",
-							fi->bodyfetch.
-							octetstart,
-							actual_cnt);
-
-						send_data(self->ci->tx,
-							  cached_msg.
-							  memdump,
-							  actual_cnt);
-
-					}
-
-					if (fi->getBodyTotal)
-						setseen = 1;
-
-				}
-
-				if (fi->getRFC822Header) {
-					/* here: msgparse_needed == 1
-					 * if this msg is in cache, retrieve it from there
-					 * otherwise only_main_header_parsing == 1 so retrieve direct
-					 * from the dbase
-					 */
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					if (cached_msg.num == thisnum) {
-						mrewind(cached_msg.
-							tmpdump);
-						tmpdumpsize =
-						    rfcheader_dump
-						    (cached_msg.tmpdump,
-						     &cached_msg.msg.
-						     rfcheader, self->args, 0,
-						     0);
-
-						mseek(cached_msg.tmpdump,
-						      0, SEEK_SET);
-
-						dbmail_imap_session_printf(self,
-							"RFC822.HEADER {%llu}\r\n",
-							tmpdumpsize);
-						send_data(self->ci->tx,
-							  cached_msg.
-							  tmpdump,
-							  tmpdumpsize);
-					} else {
-						/* remember only_main_header_parsing == 1 here ! */
-
-						/* use cached_msg.tmpdump as temporary storage */
-						mrewind(cached_msg.
-							tmpdump);
-						tmpdumpsize =
-						    rfcheader_dump
-						    (cached_msg.tmpdump,
-						     &headermsg.rfcheader,
-						     self->args, 0, 0);
-
-						mseek(cached_msg.tmpdump,
-						      0, SEEK_SET);
-
-						dbmail_imap_session_printf(self,
-							"RFC822.HEADER {%llu}\r\n",
-							tmpdumpsize);
-						send_data(self->ci->tx,
-							  cached_msg.
-							  tmpdump,
-							  tmpdumpsize);
-					}
-				}
-
-				if (fi->getRFC822Text) {
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					mrewind(cached_msg.tmpdump);
-					tmpdumpsize =
-					    db_dump_range(cached_msg.
-							  tmpdump,
-							  cached_msg.msg.
-							  bodystart,
-							  cached_msg.msg.
-							  bodyend,
-							  thisnum);
-
-					mseek(cached_msg.tmpdump, 0,
-					      SEEK_SET);
-
-					dbmail_imap_session_printf(self,
-						"RFC822.TEXT {%llu}\r\n",
-						tmpdumpsize);
-					send_data(self->ci->tx,
-						  cached_msg.tmpdump,
-						  tmpdumpsize);
-
-					setseen = 1;
-				}
-
-				if (fi->bodyfetch.itemtype >= 0) {
-					mrewind(cached_msg.tmpdump);
-
-					if (fi->bodyfetch.partspec[0]) {
-						if (fi->bodyfetch.
-						    partspec[0] == '0') {
-							dbmail_imap_session_printf(self,
-								"\r\n%s BAD protocol error\r\n",
-								self->tag);
-							trace(TRACE_DEBUG,
-							      "PROTOCOL ERROR");
-							list_freelist
-							    (&fetch_list.
-							     start);
-							db_free_msg
-							    (&headermsg);
-							return 1;
-						}
-
-						msgpart =
-						    get_part_by_num
-						    (&cached_msg.msg,
-						     fi->bodyfetch.
-						     partspec);
-
-						if (!msgpart) {
-							/* if the partspec ends on "1" or "1." the msg body
-							 * of the parent message is to be retrieved
-							 */
-
-							partspeclen =
-							    strlen(fi->
-								   bodyfetch.
-								   partspec);
-
-							if ((fi->bodyfetch.
-							     partspec
-							     [partspeclen -
-							      1] == '1'
-							     &&
-							     (partspeclen
-							      == 1
-							      || fi->
-							      bodyfetch.
-							      partspec
-							      [partspeclen
-							       - 2] ==
-							      '.'))
-							    ||
-							    ((fi->
-							      bodyfetch.
-							      partspec
-							      [partspeclen
-							       - 1] == '.'
-							      && fi->
-							      bodyfetch.
-							      partspec
-							      [partspeclen
-							       - 2] == '1')
-							     &&
-							     (partspeclen
-							      == 2
-							      || fi->
-							      bodyfetch.
-							      partspec
-							      [partspeclen
-							       - 3] ==
-							      '.'))
-							    ) {
-								/* ok find the parent of this message */
-								/* start value of k is partspeclen-2 'cause we could
-								   have partspec[partspeclen-1] == '.' right at the start
-								 */
-
-								for (k =
-								     partspeclen
-								     - 2;
-								     k >=
-								     0;
-								     k--)
-									if (fi->bodyfetch.partspec[k] == '.')
-										break;
-
-								if (k > 0) {
-									fi->bodyfetch.partspec[k] = '\0';
-									msgpart
-									    =
-									    get_part_by_num
-									    (&cached_msg.
-									     msg,
-									     fi->
-									     bodyfetch.
-									     partspec);
-									fi->bodyfetch.partspec[k] = '.';
-								} else
-									msgpart
-									    =
-									    &cached_msg.
-									    msg;
-
-								only_text_from_msgpart
-								    = 1;
-							}
-						} else {
-							only_text_from_msgpart
-							    = 0;
-						}
-					} else {
-						if (cached_msg.num ==
-						    thisnum)
-							msgpart =
-							    &cached_msg.
-							    msg;
-						else {
-							/* this will be only the case when only_main_header_parsing == 1 */
-							msgpart =
-							    &headermsg;
-						}
-					}
-
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					if (fi->bodyfetch.noseen)
-						dbmail_imap_session_printf(self, "BODY[%s",
-							fi->bodyfetch.
-							partspec);
-					else {
-						dbmail_imap_session_printf(self, "BODY[%s",
-							fi->bodyfetch.
-							partspec);
-						setseen = 1;
-					}
-
-					switch (fi->bodyfetch.itemtype) {
-					case BFIT_TEXT_SILENT:
-						if (!msgpart)
-							dbmail_imap_session_printf(self,
-								"] NIL ");
-						else {
-							tmpdumpsize = 0;
-
-							if (!only_text_from_msgpart)
-								tmpdumpsize
-								    =
-								    rfcheader_dump
-								    (cached_msg.
-								     tmpdump,
-								     &msgpart->
-								     rfcheader,
-								     self->args,
-								     0, 0);
-
-							tmpdumpsize +=
-							    db_dump_range
-							    (cached_msg.
-							     tmpdump,
-							     msgpart->
-							     bodystart,
-							     msgpart->
-							     bodyend,
-							     thisnum);
-
-							if (fi->bodyfetch.
-							    octetstart >=
-							    0) {
-								cnt =
-								    tmpdumpsize
-								    -
-								    fi->
-								    bodyfetch.
-								    octetstart;
-								if (cnt <
-								    0)
-									cnt = 0;
-								if (cnt >
-								    fi->
-								    bodyfetch.
-								    octetcnt)
-									cnt = fi->bodyfetch.octetcnt;
-
-								fprintf
-								    (self->ci->
-								     tx,
-								     "]<%llu> {%llu}\r\n",
-								     fi->
-								     bodyfetch.
-								     octetstart,
-								     cnt);
-
-								mseek
-								    (cached_msg.
-								     tmpdump,
-								     fi->
-								     bodyfetch.
-								     octetstart,
-								     SEEK_SET);
-							} else {
-								cnt =
-								    tmpdumpsize;
-								fprintf
-								    (self->ci->
-								     tx,
-								     "] {%llu}\r\n",
-								     tmpdumpsize);
-								mseek
-								    (cached_msg.
-								     tmpdump,
-								     0,
-								     SEEK_SET);
-							}
-
-							/* output data */
-							send_data(self->ci->tx,
-								  cached_msg.
-								  tmpdump,
-								  cnt);
-
-						}
-						break;
-
-
-					case BFIT_TEXT:
-						/* dump body text */
-						dbmail_imap_session_printf(self, "TEXT");
-						if (!msgpart)
-							dbmail_imap_session_printf(self,
-								"] NIL ");
-						else {
-							tmpdumpsize =
-							    db_dump_range
-							    (cached_msg.
-							     tmpdump,
-							     msgpart->
-							     bodystart,
-							     msgpart->
-							     bodyend,
-							     thisnum);
-
-							if (fi->bodyfetch.
-							    octetstart >=
-							    0) {
-								cnt =
-								    tmpdumpsize
-								    -
-								    fi->
-								    bodyfetch.
-								    octetstart;
-								if (cnt <
-								    0)
-									cnt = 0;
-								if (cnt >
-								    fi->
-								    bodyfetch.
-								    octetcnt)
-									cnt = fi->bodyfetch.octetcnt;
-
-								fprintf
-								    (self->ci->
-								     tx,
-								     "]<%llu> {%llu}\r\n",
-								     fi->
-								     bodyfetch.
-								     octetstart,
-								     cnt);
-
-								mseek
-								    (cached_msg.
-								     tmpdump,
-								     fi->
-								     bodyfetch.
-								     octetstart,
-								     SEEK_SET);
-							} else {
-								cnt =
-								    tmpdumpsize;
-								fprintf
-								    (self->ci->
-								     tx,
-								     "] {%llu}\r\n",
-								     tmpdumpsize);
-								mseek
-								    (cached_msg.
-								     tmpdump,
-								     0,
-								     SEEK_SET);
-							}
-
-							/* output data */
-							send_data(self->ci->tx,
-								  cached_msg.
-								  tmpdump,
-								  cnt);
-						}
-						break;
-
-					case BFIT_HEADER:
-						dbmail_imap_session_printf(self, "HEADER");
-						if (!msgpart
-						    ||
-						    only_text_from_msgpart)
-							dbmail_imap_session_printf(self,
-								"] NIL\r\n");
-						else {
-							tmpdumpsize =
-							    rfcheader_dump
-							    (cached_msg.
-							     tmpdump,
-							     &msgpart->
-							     rfcheader,
-							     self->args, 0, 0);
-
-							if (!tmpdumpsize) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "] NIL\r\n");
-							} else {
-								if (fi->
-								    bodyfetch.
-								    octetstart
-								    >= 0) {
-									cnt = tmpdumpsize - fi->bodyfetch.octetstart;
-									if (cnt < 0)
-										cnt = 0;
-									if (cnt > fi->bodyfetch.octetcnt)
-										cnt = fi->bodyfetch.octetcnt;
-
-									fprintf
-									    (self->ci->
-									     tx,
-									     "]<%llu> {%llu}\r\n",
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     cnt);
-
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     SEEK_SET);
-								} else {
-									cnt = tmpdumpsize;
-									fprintf
-									    (self->ci->
-									     tx,
-									     "] {%llu}\r\n",
-									     tmpdumpsize);
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     0,
-									     SEEK_SET);
-								}
-
-								/* output data */
-								send_data
-								    (self->ci->
-								     tx,
-								     cached_msg.
-								     tmpdump,
-								     cnt);
-
-							}
-						}
-						break;
-
-					case BFIT_HEADER_FIELDS:
-						dbmail_imap_session_printf(self,
-							"HEADER.FIELDS (");
-
-						isfirstout = 1;
-						for (k = 0;
-						     k <
-						     fi->bodyfetch.argcnt;
-						     k++) {
-							if (isfirstout) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "%s",
-								     self->args[k
-									  +
-									  fi->
-									  bodyfetch.
-									  argstart]);
-								isfirstout
-								    = 0;
-							} else
-								fprintf
-								    (self->ci->
-								     tx,
-								     " %s",
-								     self->args[k
-									  +
-									  fi->
-									  bodyfetch.argstart]);
-						}
-
-						dbmail_imap_session_printf(self, ")] ");
-
-						if (!msgpart
-						    ||
-						    only_text_from_msgpart)
-							dbmail_imap_session_printf(self,
-								"NIL\r\n");
-						else {
-							tmpdumpsize =
-							    rfcheader_dump
-							    (cached_msg.
-							     tmpdump,
-							     &msgpart->
-							     rfcheader,
-							     &self->args[fi->
-								   bodyfetch.argstart],
-							     fi->bodyfetch.
-							     argcnt, 1);
-
-							if (!tmpdumpsize) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "NIL\r\n");
-							} else {
-								if (fi->
-								    bodyfetch.
-								    octetstart
-								    >= 0) {
-									cnt = tmpdumpsize - fi->bodyfetch.octetstart;
-									if (cnt < 0)
-										cnt = 0;
-									if (cnt > fi->bodyfetch.octetcnt)
-										cnt = fi->bodyfetch.octetcnt;
-
-									fprintf
-									    (self->ci->
-									     tx,
-									     "<%llu> {%llu}\r\n",
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     cnt);
-
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     SEEK_SET);
-								} else {
-									cnt = tmpdumpsize;
-									fprintf
-									    (self->ci->
-									     tx,
-									     "{%llu}\r\n",
-									     tmpdumpsize);
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     0,
-									     SEEK_SET);
-								}
-
-								/* output data */
-								send_data
-								    (self->ci->
-								     tx,
-								     cached_msg.
-								     tmpdump,
-								     cnt);
-
-							}
-						}
-						break;
-					case BFIT_HEADER_FIELDS_NOT:
-						dbmail_imap_session_printf(self,
-							"HEADER.FIELDS.NOT (");
-
-						isfirstout = 1;
-						for (k = 0;
-						     k <
-						     fi->bodyfetch.argcnt;
-						     k++) {
-							if (isfirstout) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "%s",
-								     self->args[k
-									  +
-									  fi->
-									  bodyfetch.argstart]);
-								isfirstout
-								    = 0;
-							} else
-								fprintf
-								    (self->ci->
-								     tx,
-								     " %s",
-								     self->args[k
-									  +
-									  fi->
-									  bodyfetch.argstart]);
-						}
-
-						dbmail_imap_session_printf(self, ")] ");
-
-						if (!msgpart
-						    ||
-						    only_text_from_msgpart)
-							dbmail_imap_session_printf(self,
-								"NIL\r\n");
-						else {
-							tmpdumpsize =
-							    rfcheader_dump
-							    (cached_msg.
-							     tmpdump,
-							     &msgpart->
-							     rfcheader,
-							     &self->args[fi->
-								   bodyfetch.argstart],
-							     fi->bodyfetch.
-							     argcnt, 0);
-
-							if (!tmpdumpsize) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "NIL\r\n");
-							} else {
-								if (fi->
-								    bodyfetch.
-								    octetstart
-								    >= 0) {
-									cnt = tmpdumpsize - fi->bodyfetch.octetstart;
-									if (cnt < 0)
-										cnt = 0;
-									if (cnt > fi->bodyfetch.octetcnt)
-										cnt = fi->bodyfetch.octetcnt;
-
-									fprintf
-									    (self->ci->
-									     tx,
-									     "<%llu> {%llu}\r\n",
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     cnt);
-
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     SEEK_SET);
-								} else {
-									cnt = tmpdumpsize;
-									fprintf
-									    (self->ci->
-									     tx,
-									     "{%llu}\r\n",
-									     tmpdumpsize);
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     0,
-									     SEEK_SET);
-								}
-
-								/* output data */
-								send_data
-								    (self->ci->
-								     tx,
-								     cached_msg.
-								     tmpdump,
-								     cnt);
-
-							}
-						}
-						break;
-					case BFIT_MIME:
-						dbmail_imap_session_printf(self, "MIME] ");
-
-						if (!msgpart)
-							dbmail_imap_session_printf(self,
-								"NIL\r\n");
-						else {
-							tmpdumpsize =
-							    mimeheader_dump
-							    (cached_msg.
-							     tmpdump,
-							     &msgpart->
-							     mimeheader);
-
-							if (!tmpdumpsize) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "NIL\r\n");
-							} else {
-								if (fi->
-								    bodyfetch.
-								    octetstart
-								    >= 0) {
-									cnt = tmpdumpsize - fi->bodyfetch.octetstart;
-									if (cnt < 0)
-										cnt = 0;
-									if (cnt > fi->bodyfetch.octetcnt)
-										cnt = fi->bodyfetch.octetcnt;
-
-									fprintf
-									    (self->ci->
-									     tx,
-									     "<%llu> {%llu}\r\n",
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     cnt);
-
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     fi->
-									     bodyfetch.
-									     octetstart,
-									     SEEK_SET);
-								} else {
-									cnt = tmpdumpsize;
-									fprintf
-									    (self->ci->
-									     tx,
-									     "{%llu}\r\n",
-									     tmpdumpsize);
-									mseek
-									    (cached_msg.
-									     tmpdump,
-									     0,
-									     SEEK_SET);
-								}
-
-								/* output data */
-								send_data
-								    (self->ci->
-								     tx,
-								     cached_msg.
-								     tmpdump,
-								     cnt);
-
-							}
-						}
-
-						break;
-					default:
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE internal server error\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						db_free_msg(&headermsg);
-						return -1;
-					}
-				}
-
-
-				/* set \Seen flag if necessary; note the absence of an error-check 
-				 * for db_get_msgflag()!
-				 */
-				if (setseen && db_get_msgflag("seen", thisnum, ud->mailbox.uid) != 1) {
-					/* only if the user has an ACL which grants
-					   him rights to set the flag should the
-					   flag be set! */
-					result = acl_has_right(ud->userid, ud->mailbox.uid, ACL_RIGHT_SEEN);
-					if (result == -1) {
-						dbmail_imap_session_printf(self, "\r\n *BYE internal dbase error\r\n");
-						list_freelist(&fetch_list.start);
-						db_free_msg(&headermsg);
-						return -1;
-					}
-					
-					if (result == 1 && ud->mailbox.permission == IMAPPERM_READWRITE) {
-						result = db_set_msgflag(thisnum, ud->mailbox.uid, setSeenSet, IMAPFA_ADD);
-						if (result == -1) {
-							dbmail_imap_session_printf(self, "\r\n* BYE internal dbase error\r\n");
-							list_freelist(&fetch_list.  start);
-							db_free_msg(&headermsg);
-							return -1;
-						}
-					}
-
-					fi->getFlags = 1;
-					dbmail_imap_session_printf(self, " ");
-				}
-
-				/* FLAGS ? */
-				if (fi->getFlags) {
-					if (isfirstfetchout)
-						isfirstfetchout = 0;
-					else
-						dbmail_imap_session_printf(self, " ");
-
-					dbmail_imap_session_printf(self, "FLAGS (");
-
-					isfirstout = 1;
-
-					result =
-					    db_get_msgflag_all(thisnum,
-							       ud->mailbox.
-							       uid,
-							       msgflags);
-					if (result == -1) {
-						dbmail_imap_session_printf(self,
-							"\r\n* BYE internal dbase error\r\n");
-						list_freelist(&fetch_list.
-							      start);
-						db_free_msg(&headermsg);
-						return -1;
-					}
-
-					for (j = 0; j < IMAP_NFLAGS; j++) {
-						if (msgflags[j]) {
-							if (isfirstout) {
-								fprintf
-								    (self->ci->
-								     tx,
-								     "\\%s",
-								     imap_flag_desc
-								     [j]);
-								isfirstout
-								    = 0;
-							} else
-								fprintf
-								    (self->ci->
-								     tx,
-								     " \\%s",
-								     imap_flag_desc
-								     [j]);
-						}
-					}
-					dbmail_imap_session_printf(self, ")");
-				}
-
-				curr = curr->nextnode;
-			}
-
-			if (!bad_response_send)
-				dbmail_imap_session_printf(self, ")\r\n");
-
+			trace(TRACE_DEBUG, "Fetching msgID %llu (fetch num %llu)", self->msg_idnr, i + 1);
+			/* go fetch the items */
+			fflush(self->ci->tx);
+			if (dbmail_imap_session_fetch_get_items(self) < 0)
+				return -1;
 		}
 	}
 
 	mreset(cached_msg.tmpdump);
-	list_freelist(&fetch_list.start);
-	db_free_msg(&headermsg);
-
-	dbmail_imap_session_printf(self, "%s OK %sFETCH completed\r\n", self->tag,
-		imapcommands_use_uid ? "UID " : "");
+	dbmail_imap_session_printf(self, "%s OK %sFETCH completed\r\n", self->tag, self->use_uid ? "UID " : "");
 	return 0;
 }
 
 
+
 /*
  * _ic_store()
  *
diff -urNad /usr/src/dbmail2/dbmail-2.1/imaputil.c dbmail-2.1/imaputil.c
--- /usr/src/dbmail2/dbmail-2.1/imaputil.c	2004-10-21 11:57:23.000000000 +0200
+++ dbmail-2.1/imaputil.c	2004-10-21 15:50:38.000000000 +0200
@@ -57,12 +57,22 @@
 /* cache */
 extern cache_t cached_msg;
 
-extern const char AcceptedChars[];
-extern const char AcceptedTagChars[];
-extern const char AcceptedMailboxnameChars[];
+/* consts */
+const char AcceptedChars[] =
+    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
+    "!@#$%^&*()-=_+`~[]{}\\|'\" ;:,.<>/? \n\r";
+
+const char AcceptedTagChars[] =
+    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
+    "!@#$%^&-=_`~\\|'\" ;:,.<>/? ";
+
+const char AcceptedMailboxnameChars[] =
+    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-=/ _.&,+";
+
 extern const char *month_desc[];
 
 
+
 char base64encodestring[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
